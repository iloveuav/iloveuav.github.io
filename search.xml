<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pavlov技术分享(捂脸)</title>
    <url>/2020/05/12/avlov%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB-%E6%8D%82%E8%84%B8/</url>
    <content><![CDATA[<p>皮一下很开心</p>
<a id="more"></a>

<h3 id="手枪"><a href="#手枪" class="headerlink" title="手枪"></a>手枪</h3><video src="http://q9uen5wtx.bkt.clouddn.com/%E6%85%A2%E5%8A%A8%E4%BD%9C%E6%89%8B%E6%9E%AA.mp4" controls="controls" style="max-width: 100%; display: block; margin-left: auto; margin-right: auto;">
your browser does not support the video tag
</video>

<h3 id="m4a1自动步枪"><a href="#m4a1自动步枪" class="headerlink" title="m4a1自动步枪"></a>m4a1自动步枪</h3><video src="http://q9uen5wtx.bkt.clouddn.com/%5Bpavlov%5DDie.mp4" controls="controls" style="max-width: 100%; display: block; margin-left: auto; margin-right: auto;">
your browser does not support the video tag
</video>

<p>千钧一发 不是你Die就是我Die</p>
<h3 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h3><p><a href="https://www.bilibili.com/video/BV1jQ4y1N7gj" target="_blank" rel="noopener">【VR放鞭炮】《Pavlov》爆头有种打气球的感觉</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>持枪要平滑移动 远距离一定要双手持枪</p>
<p>快速分析先瞄准哪个方向</p>
<p>已经到身边就不要再近距离机瞄瞄准应该马上切换为体态瞄准（自己瞎想的词）</p>
<p>枪法 = 感觉 + 眼神好</p>
]]></content>
  </entry>
  <entry>
    <title>7天前端面试复习（5.1-5.8）</title>
    <url>/2020/04/30/7%E5%A4%A9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%EF%BC%885.1-5.8%EF%BC%89/</url>
    <content><![CDATA[<p>由于才疏学浅本博客大部分内容都是引用其他大佬的博客<br>主要是为了方便复习和理解~</p>
<a id="more"></a>

<h2 id="Day1（Git-前后端分离技术）"><a href="#Day1（Git-前后端分离技术）" class="headerlink" title="Day1（Git/前后端分离技术）"></a>Day1（Git/前后端分离技术）</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>git部分参考自廖雪峰的官方网站 <a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>
<h5 id="创建版本库（又名仓库-repository）"><a href="#创建版本库（又名仓库-repository）" class="headerlink" title="创建版本库（又名仓库 repository）"></a>创建版本库（又名仓库 repository）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</span><br><span class="line"></span><br><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure>
<p><strong><em>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</em></strong></p>
<h5 id="基本命令速览："><a href="#基本命令速览：" class="headerlink" title="基本命令速览："></a>基本命令速览：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过git init命令把这个目录变成Git可以管理的仓库：</span><br><span class="line">用命令git add告诉Git，把文件添加到仓库：</span><br><span class="line">用命令git commit告诉Git，把文件提交到仓库：</span><br><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</span><br><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status命令可以让我们时刻掌握仓库当前的状态</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式</span><br><span class="line">如：$ git diff readme.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在Git中，我们用git log命令查看历史记录，显示从最近到最远的提交日志</span><br><span class="line">类似1094adb7b9b3807259d8cb349e7df1d4d6477073 的是commit id（版本号）</span><br><span class="line"></span><br><span class="line">为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</span><br></pre></td></tr></table></figure>
<p>回退到上一个版本：<br>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p>
<p>使用git reset命令：<br>                                       git status检测更改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">$ git reset --hard 1094a</span><br><span class="line">要撤销提交但保留更改：git reset  +当前文件</span><br><span class="line">要修改提交中的更改：git reset --hard +当前文件名</span><br><span class="line"></span><br><span class="line">你使用了 --hard，所以你的文件将重置到提交 B 时的状态。</span><br></pre></td></tr></table></figure>
<p>可退可进，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb…，于是就可以指定回到未来的某个版本</p>
<p>假如你关了电脑 不知道id没办法穿越怎么办，Git提供了一个命令git reflog用来记录你的每一次命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>
<p>现在，你又可以乘坐时光机回到未来了。</p>
<h6 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h6><p>Git会告诉你，git checkout – file可以丢弃工作区的修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br><span class="line">命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</span><br><span class="line">一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</span><br><span class="line">一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</span><br><span class="line"></span><br><span class="line">总之，就是让这个文件回到最近一次git commit或git add时的状态。</span><br></pre></td></tr></table></figure>

<p>用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区</file></p>
<p>  修改相关小总结：<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。</span><br><span class="line"></span><br><span class="line">场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。</span><br><span class="line"></span><br><span class="line">场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</span><br><span class="line"></span><br><span class="line">git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</span><br></pre></td></tr></table></figure></p>
<h6 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h6><p>GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">要关联一个远程库，使用命令：</span><br><span class="line">$git remote add origin git@server-name:path/repo-name.git；</span><br><span class="line">$ git remote add origin github邮箱：用户名/仓库名.git</span><br><span class="line"></span><br><span class="line">关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</span><br><span class="line">此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/30/7%E5%A4%A9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%EF%BC%885.1-5.8%EF%BC%89/%5Cimages%5Cpasted-6.png%5C" alt="upload successful"></p>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。<br>Git支持多种协议，包括https，但ssh协议速度最快。</p>
<h6 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h6><p>创建dev分支，然后切换到dev分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure>
<p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &apos;dev&apos;</span><br></pre></td></tr></table></figure>

<p>用git branch命令查看当前分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
<p>  git branch命令会列出所有分支，当前分支前面会标一个*号。</p>
<p>  dev分支的工作完成，我们就可以切换回master分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure>

<p>把dev分支的工作成果合并到master分支上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure>
<p>git merge命令用于合并指定分支到当前分支。</p>
<p>合并完成后，就可以放心地删除dev分支了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure>
<p>switch<br>我们注意到切换分支使用git checkout <branch>，而前面讲过的撤销修改则是git checkout – <file>，同一个命令，有两种作用，确实有点令人迷惑。</file></branch></p>
<p>实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支：</p>
<p>创建并切换到新的dev分支，可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git switch -c dev</span><br></pre></td></tr></table></figure>
<p>直接切换到已有的master分支，可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br></pre></td></tr></table></figure>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：git branch</p>
<p>创建分支：git branch <name></name></p>
<p>切换分支：git checkout <name>或者git switch <name></name></name></p>
<p>创建+切换分支：git checkout -b <name>或者git switch -c <name></name></name></p>
<p>合并某分支到当前分支：git merge <name></name></p>
<p>删除分支：git branch -d <name></name></p>
<h6 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h6><p>  当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用git log –graph命令可以看到分支合并图。</p>
<h6 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在实际开发中，我们应该按照几个基本原则进行分支管理：</span><br><span class="line"></span><br><span class="line">首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</span><br><span class="line"></span><br><span class="line">那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</span><br><span class="line"></span><br><span class="line">你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</span><br></pre></td></tr></table></figure>

<p>Bug分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</span><br><span class="line"></span><br><span class="line">当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；</span><br><span class="line"></span><br><span class="line">在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</span><br></pre></td></tr></table></figure>
<p>Feature分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开发一个新feature，最好新建一个分支；</span><br><span class="line"></span><br><span class="line">如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。</span><br></pre></td></tr></table></figure>
<p>多人协作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看远程库信息，使用git remote -v；</span><br><span class="line"></span><br><span class="line">本地新建的分支如果不推送到远程，对其他人就是不可见的；</span><br><span class="line"></span><br><span class="line">从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</span><br><span class="line"></span><br><span class="line">在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</span><br><span class="line"></span><br><span class="line">建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；</span><br><span class="line"></span><br><span class="line">从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</span><br></pre></td></tr></table></figure>
<p>Rebase</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rebase操作可以把本地未push的分叉提交历史整理成直线；</span><br><span class="line"></span><br><span class="line">rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</span><br></pre></td></tr></table></figure>
<h3 id="Git前端面试题"><a href="#Git前端面试题" class="headerlink" title="Git前端面试题"></a>Git前端面试题</h3><p><a href="https://blog.csdn.net/nobody_1/article/details/88956315" target="_blank" rel="noopener">https://blog.csdn.net/nobody_1/article/details/88956315</a></p>
<h3 id="前后端分离技术"><a href="#前后端分离技术" class="headerlink" title="前后端分离技术"></a>前后端分离技术</h3><h4 id="浏览器如何和服务器交互"><a href="#浏览器如何和服务器交互" class="headerlink" title="浏览器如何和服务器交互"></a>浏览器如何和服务器交互</h4><p><img src="http://q9uen5wtx.bkt.clouddn.com/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A.png" alt="浏览器请求流程"></p>
<p><img src="http://q9uen5wtx.bkt.clouddn.com/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B.png" alt="浏览器请求流程2"></p>
<h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><p><img src="http://q9uen5wtx.bkt.clouddn.com/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="同步异步的区别.png"></p>
<ul>
<li>同步异步的区别.png </li>
</ul>
<p><a href="https://blog.csdn.net/persistencegoing/article/details/88641992" target="_blank" rel="noopener">简单介绍下Ajax</a></p>
<p><a href="https://www.bilibili.com/video/BV1ZK411L7Mg?from=search&seid=3199266144308194209" target="_blank" rel="noopener">javascript面试技巧之ajax请求与同源策略</a></p>
<p>传统网站在网速慢、表单内容提交不合格、页面跳转资源加载浪费下会各种影响用户体验。<br>Ajax可以实现页面无刷新更新数据（异步局部更新），提高用户体验。</p>
<p><img src="http://q9uen5wtx.bkt.clouddn.com/ajax%E5%8E%9F%E7%94%9Fapi%E5%8F%8A%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7.png" alt="ajax原生api及核心属性.png"></p>
<ul>
<li>ajax原生api及核心属性.png </li>
</ul>
<p>应用场景：（不刷新页面情况下请求服务器资源）<br>1、页面上拉加载更多<br>2、列表数据无刷新分页<br>3、表单项离开焦点数据验证<br>4、搜索框提示文字下拉列表</p>
<p>运行环境：在网站环境中才能生效 如：Express （基于Node.js 平台的Web应用开发框架）</p>
<p>AJAX = 异步 JavaScript和 XML。</p>
<p>AJAX 是一种用于创建快速动态网页的技术。</p>
<p>XMLHttpRequest 是 AJAX 的基础。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest对象：用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</span><br></pre></td></tr></table></figure>

<p>创建 XMLHttpRequest 对象的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">variable=new XMLHttpRequest();</span><br></pre></td></tr></table></figure>
<p>老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">variable=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br></pre></td></tr></table></figure>
<p>实例：<br><a href="https://www.w3school.com.cn/xml/xml_http.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/xml/xml_http.asp</a></p>
<p>onreadystatechange 是一个事件句柄（指事件发生时要进行的操作。）。它的值 (state_Change) 是一个函数的名称，当 XMLHttpRequest 对象的状态发生改变时，会触发此函数。状态从 0 (uninitialized) 到 4 (complete) 进行变化。仅在状态为 4 时，我们才执行代码。</p>
<p><strong><em>为什么使用 Async=true ？</em></strong></p>
<p>我们的实例在 open() 的第三个参数中使用了 “true”。<br>该参数规定请求是否异步处理。<br>True 表示脚本会在 send() 方法之后继续执行，而不等待来自服务器的响应。<br>onreadystatechange 事件使代码复杂化了。但是这是在没有得到服务器响应的情况下，防止代码停止的最安全的方法。</p>
<p>通过把该参数设置为 “false”，可以省去额外的 onreadystatechange 代码。如果在请求失败时是否执行其余的代码无关紧要，那么可以使用这个参数。</p>
<p><img src="http://q9uen5wtx.bkt.clouddn.com/Ajax%E4%BC%98%E7%BC%BA%E7%82%B9.png" alt="Ajax优缺点.png"></p>
<ul>
<li>Ajax优缺点.png</li>
</ul>
<h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><p><strong><em>what</em></strong>:</p>
<ul>
<li><a href="https://www.cnblogs.com/bzsheng/p/12527357.html" target="_blank" rel="noopener">https://www.cnblogs.com/bzsheng/p/12527357.html</a></li>
</ul>
<p>跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能同源使用的限制。</p>
<p>​    常见的跨域场景：</p>
<p>同一域名，不同文件或路径、不同端口、不同协议<br>域名和域名对应相同ip、主域相同但子域不同<br>不同域名</p>
<p><strong><em>how</em></strong>:</p>
<ul>
<li><p>Jsonp跨域:<a href="https://blog.csdn.net/DFF1993/article/details/79925874" target="_blank" rel="noopener">https://blog.csdn.net/DFF1993/article/details/79925874</a></p>
<p>Nodejs代理：</p>
</li>
<li><p><a href="https://www.cnblogs.com/Aoobruce/p/8195933.html" target="_blank" rel="noopener">https://www.cnblogs.com/Aoobruce/p/8195933.html</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_37960007/article/details/91359579" target="_blank" rel="noopener">https://blog.csdn.net/qq_37960007/article/details/91359579</a></p>
</li>
</ul>
<p>Nginx跨域：</p>
<ul>
<li><a href="https://jingyan.baidu.com/article/4d58d541f87a78ddd4e9c0c8.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/4d58d541f87a78ddd4e9c0c8.html</a></li>
</ul>
<p>CORS跨域：</p>
<ul>
<li><a href="https://www.jianshu.com/p/98d4bc7565b2" target="_blank" rel="noopener">https://www.jianshu.com/p/98d4bc7565b2</a></li>
</ul>
<h4 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h4><p><img src="http://q9uen5wtx.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98.png" alt="如何解决跨域问题.png"></p>
<p><img src="http://q9uen5wtx.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%982.png" alt="如何解决跨域问题.png"></p>
<ul>
<li>如何解决跨域问题.png</li>
</ul>
<h4 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h4><p><strong><em>what？</em></strong>：<a href="https://www.zhihu.com/question/53064386" target="_blank" rel="noopener">https://www.zhihu.com/question/53064386</a></p>
<p>1.浏览器发出请求2.服务器监听到80端口（或443）有请求过来，并解析url路径3.根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等）4.浏览器根据数据包的<code>Content-Type</code>来决定如何解析数据</p>
<p>简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。</p>
<h5 id="从-vue-router-来看前端路由实现原理"><a href="#从-vue-router-来看前端路由实现原理" class="headerlink" title="从 vue-router 来看前端路由实现原理"></a>从 vue-router 来看前端路由实现原理</h5><ul>
<li>本质上就是检测 url 的变化，截获 url 地址，然后解析来匹配路由规则。</li>
</ul>
<p>在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://segmentfault.com/a/1190000011956628#articleHeader2</span><br></pre></td></tr></table></figure>
<p>检测到 hash 的变化后，就可以通过替换 DOM 的方式来实现页面的更换。</p>
<p>14年后，因为HTML5标准发布。多了两个 API，<code>pushState</code> 和 <code>replaceState</code>，通过这两个 API 可以改变 url 地址且不会发送请求。同时还有 <code>onpopstate</code> 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 HTML5 的实现，单页路由的 url 就不会多出一个<code>#</code>，变得更加美观。但因为没有 <code>#</code> 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。具体可以见：<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener">HTML5 histroy 模式</a></p>
<p>异步交互的最高级体验是什么？</p>
<p><a href="https://www.jianshu.com/p/098af61bbe04" target="_blank" rel="noopener">PWA</a>，让前端页面可以做到离线操作（是不是越来越像原生 app 了？）</p>
<p><strong>* how?*</strong> : <a href="https://segmentfault.com/a/1190000006740604?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006740604?utm_source=tag-newest</a></p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p><strong><em>what?</em></strong>: </p>
<p><a href="https://www.cnblogs.com/qcloud1001/p/10101067.html" target="_blank" rel="noopener">cookie是什么</a></p>
<p><strong><em>How?</em></strong>:<br><a href="https://blog.csdn.net/zhang070514/article/details/74018769" target="_blank" rel="noopener">https://blog.csdn.net/zhang070514/article/details/74018769</a></p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p><strong><em>what?</em></strong>: <a href="https://www.cnblogs.com/qcloud1001/p/10101067.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcloud1001/p/10101067.html</a></p>
<p><strong><em>How?</em></strong>:<br><a href="https://blog.csdn.net/zhang070514/article/details/74018769" target="_blank" rel="noopener">https://blog.csdn.net/zhang070514/article/details/74018769</a></p>
<p>cookie，session和 localstorage 的区别:</p>
<p>session&amp;cookie:<a href="https://www.dazhuanlan.com/2019/12/30/5e09a58fee920/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/12/30/5e09a58fee920/</a></p>
<p>cookie&amp;session&amp;localstorage<a href="https://blog.csdn.net/lizhengxv/article/details/81541977" target="_blank" rel="noopener">https://blog.csdn.net/lizhengxv/article/details/81541977</a></p>
<h2 id="Day2（H5-CSS-ES6）"><a href="#Day2（H5-CSS-ES6）" class="headerlink" title="Day2（H5/CSS/ES6）"></a>Day2（H5/CSS/ES6）</h2><h3 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h3><p>H5:<a href="https://blog.csdn.net/caseywei/article/details/81105544" target="_blank" rel="noopener">关于H5的20道面试题及答案</a></p>
<p>40个重要的HTML5面试题及答案:<a href="https://www.cnblogs.com/dion-90/articles/8481641.html" target="_blank" rel="noopener">40个重要的HTML5面试题及答案</a></p>
<h3 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h3><p>Css:<a href="https://www.w3cschool.cn/css/css-display-visibility.html" target="_blank" rel="noopener">W3cschool</a></p>
<p>浅谈CSS中的伪元素和伪类:<a href="https://www.w3cschool.cn/css_series/css_series-pwkt24q2.html" target="_blank" rel="noopener">浅谈CSS中的伪元素和伪类</a></p>
<p>伪类和伪元素都不出现在源文件和文档树中。也就是说在html源文件中是看不到伪类和伪元素的。</p>
<p>一句话总结不同之处就是，伪元素产生新对象，在DOM树中看不到，但是可以操作；伪类不产生新的对象，仅是DOM中一个元素的不同状态；</p>
<p>Css布局模型:<a href="https://www.w3cschool.cn/css_series/css_series-ig1c24q4.html" target="_blank" rel="noopener">Css布局模型</a></p>
<p>浮动（float）布局会使元素脱离文档流，不脱离文本流。元素无视它的存在，而元素其中的文本会围绕在它周围，但是它不会脱离DOM树，用浏览器的审查元素可以看到脱离文档流的它。<br>绝对定位position: absolute;和position: fixed;布局会使元素既脱离文档流，又脱离文本流。（元素和文本都定位不到它的存在）。<br>注：position: fixed;是position: absolute; 的一个子级，两者都是绝对定位。</p>
<p>技巧：</p>
<p><a href="https://www.w3cschool.cn/css_series/css_series-2wj724q8.html" target="_blank" rel="noopener">CSS如何让页脚固定在页面底部</a></p>
<p><a href="https://www.w3cschool.cn/css_series/css_series-2wj724q8.html" target="_blank" rel="noopener">CSS如何让页脚固定在页面底部</a></p>
<p><a href="https://www.jianshu.com/p/150ad2db82b7" target="_blank" rel="noopener">margin取负值</a></p>
<p><a href="https://www.jianshu.com/p/c8a329678fcf" target="_blank" rel="noopener">负外边距</a></p>
<p><a href="https://blog.csdn.net/sinat_36422236/article/details/88763187" target="_blank" rel="noopener">BFC</a></p>
<p><a href="https://www.bilibili.com/video/BV1BJ41197XE?from=search&seid=15902995013624924703" target="_blank" rel="noopener">flex伸缩布局Pink老师の视频</a></p>
<p><a href="https://www.bilibili.com/video/BV17J411x7Mo" target="_blank" rel="noopener">CSS圣杯布局和双飞翼布局</a></p>
<p><a href="https://www.bilibili.com/video/BV167411y7m5" target="_blank" rel="noopener">CSS垂直居中 </a></p>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p><a href="https://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">ES6文档</a></p>
<p>前端面试题整理—ES6篇:<a href="https://www.cnblogs.com/theblogs/p/10575845.html" target="_blank" rel="noopener">前端面试题整理—ES6篇</a></p>
<p><a href="http://blog.zhencai.xyz/archives/20200428" target="_blank" rel="noopener">甄菜—前端面试基础-ES6</a></p>
<p>ES6析构赋值:[ES6析构赋值]:(<a href="https://www.cnblogs.com/xiaohuochai/p/7243166.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaohuochai/p/7243166.html</a>)</p>
<h2 id="Day3（JS相关-amp-ES6-amp-LeedCode）"><a href="#Day3（JS相关-amp-ES6-amp-LeedCode）" class="headerlink" title="Day3（JS相关&amp;ES6&amp;LeedCode）"></a>Day3（JS相关&amp;ES6&amp;LeedCode）</h2><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><p>MDN:[javascript]（<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript）" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript）</a></p>
<p><a href="https://www.cnblogs.com/cosiray/p/4512969.html" target="_blank" rel="noopener">javascript中apply、call和bind的区别</a></p>
<p><a href="https://www.bilibili.com/video/BV1iE411q7Qd?from=search&seid=663896737256113208" target="_blank" rel="noopener">闭包</a></p>
<p>闭包就是可以在作用域外部访问作用域内部的变量</p>
<h3 id="关于-："><a href="#关于-：" class="headerlink" title="关于$："></a>关于$：</h3><p>$在JS中本身只是一个符号而已，但在JS应用库JQUERY的作者将之做为一个自定义函数名了，这个函数是获取指定网页元素的函数，使用非常之频繁，我自己在不用JQUERY的情况，一般自己也会自定义一个$函数。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function $(Eid)&#123;</span><br><span class="line"> return document.getElementById(Eid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">标签选择器$(&apos;p&apos;)、类选择器$(&apos;.myClass&apos;)、id选择器$(&apos;#myId&apos;)相对简单，不多说。不过有一点——$(&apos;div&gt;ul&apos;)和$(&apos;div ul&apos;)是有区别的， $(&apos;div&gt;ul&apos;)是&lt;div&gt;的直接后代里找&lt;ul&gt;；而$(&apos;div ul&apos;)是在&lt;div&gt;的***所有后代***里找&lt;ul&gt;。 </span><br><span class="line">所以，$(&apos;#sId&gt;li&apos;)所选择的是id为&quot;sId&quot;的所有&lt;li&gt;孩子节点，即使这个&lt;li&gt;的后代还有&lt;li&gt;也不是它所找的范围（所找到的DOM对象，只是它本级的DOM对象。）。而$(&apos;#sId li:not(.horizontal)&apos;)，就是指类名&quot;sId&quot;里面的所有li的子孙中没有horizontal类的所有元素。——这里的not()是一个negation pseudo class. </span><br><span class="line">这里返回的是一个jQurey对象，一个数组对象，这个jQuery对象的长度可用.length()得到。</span><br></pre></td></tr></table></figure>
<h3 id="Object-defineProperty-有什么缺陷？"><a href="#Object-defineProperty-有什么缺陷？" class="headerlink" title="Object.defineProperty 有什么缺陷？"></a>Object.defineProperty 有什么缺陷？</h3><p>Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。<br>Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。<br>Object.defineProperty本身有一定的监控到数组下标变化的能力：<br>Object.defineProperty本身是可以监控到数组下标的变化的，但是在 Vue 中，从性能/体验的性价比考虑，尤大大就弃用了这个特性。</p>
<h3 id="e-preventDefault-与e-stopPropagation-的区别"><a href="#e-preventDefault-与e-stopPropagation-的区别" class="headerlink" title="e.preventDefault()与e.stopPropagation()的区别"></a>e.preventDefault()与e.stopPropagation()的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">event.stopPropagation()方法：当前的事件执行，但是不会向上冒泡。</span><br><span class="line">event.preventDefault()方法： 当前事件不执行，会向上冒泡到父级元素。</span><br><span class="line">return fasle  : 相当于同时执行这两个方法，跳出事件。</span><br></pre></td></tr></table></figure>

<h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><p>what:<a href="https://www.cnblogs.com/loveyaxin/p/11151586.html" target="_blank" rel="noopener">原型与原型链</a></p>
<p>相关题：<a href="https://www.jianshu.com/p/50469a246a67" target="_blank" rel="noopener">让你感受不一样的原型链</a></p>
<p>继承与原型链:强烈推荐看这篇<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承与原型链</a></p>
<p>原型链继承的优缺点：<a href="https://www.jianshu.com/p/1ad5815bafcb" target="_blank" rel="noopener">原型链继承的优缺点</a></p>
<p>一、prototype</p>
<p>在JavaScript中，每个函数都有一个prototype属性，这个属性指向函数的原型对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(age) &#123;</span><br><span class="line">    this.age = age       </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &apos;jamin&apos;</span><br><span class="line">var person1 = new Person()</span><br><span class="line">var person2 = new Person()</span><br><span class="line">console.log(person1.name) //jamin	</span><br><span class="line">console.log(person2.name)  //jamin</span><br></pre></td></tr></table></figure>
<p>原型的概念：每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hasOwnProperty 是 JavaScript 中唯一一个处理属性并且不会遍历原型链的方法。（译者注：原文如此。另一种这样的方法：Object.keys()）</span><br><span class="line"></span><br><span class="line">注意：检查属性是否为 undefined 是不能够检查其是否存在的。该属性可能已存在，但其值恰好被设置成了 undefined。</span><br></pre></td></tr></table></figure>
<p>拓展原型链的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo()&#123;&#125;</span><br><span class="line">foo.prototype = &#123;</span><br><span class="line">  foo_prop: &quot;foo val&quot;</span><br><span class="line">&#125;;</span><br><span class="line">function bar()&#123;&#125;</span><br><span class="line">var proto = new foo;</span><br><span class="line">proto.bar_prop = &quot;bar val&quot;;</span><br><span class="line">bar.prototype = proto;</span><br><span class="line">var inst = new bar;</span><br><span class="line">console.log(inst.foo_prop);</span><br><span class="line">console.log(inst.bar_prop);</span><br><span class="line">支持目前以及所有可想象到的浏览器(IE5.5都可以使用). 这种方法非常快，非常符合标准，并且充分利用JIST优化。</span><br></pre></td></tr></table></figure>
<h3 id="原生Dom操作"><a href="#原生Dom操作" class="headerlink" title="原生Dom操作"></a>原生Dom操作</h3><p><a href="https://www.cnblogs.com/zhuzhenwei918/p/7463329.html" target="_blank" rel="noopener">原生JavaScript的DOM操作方法总结</a></p>
<p>Dom👉文档对象模型 (Document Object Model)</p>
<p>👇</p>
<blockquote>
<p>将web页面和脚本或程序语言连接起来</p>
</blockquote>
<h4 id="DOM-创建"><a href="#DOM-创建" class="headerlink" title="DOM 创建"></a>DOM 创建</h4><p>基本创建方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var el1 = document.createElement(&apos;div&apos;);</span><br><span class="line">var el2 = document.createElement(&apos;input&apos;);</span><br><span class="line">var node = document.createTextNode(&apos;hello world!&apos;);</span><br></pre></td></tr></table></figure>
<p>我们可以通过元素的nodetype属性来判断这个节点的类型</p>
<h3 id="DOM-查询"><a href="#DOM-查询" class="headerlink" title="DOM 查询"></a>DOM 查询</h3><p>　　元素查询的API返回的结果是DOM节点或者是DOM节点的列表，document提供了下面几种查询方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 返回当前文档中第一个类名为 &quot;myclass&quot; 的元素</span><br><span class="line">var el = document.querySelector(&quot;.myclass&quot;);</span><br><span class="line"></span><br><span class="line">// 返回一个文档中所有的class为&quot;note&quot;或者 &quot;alert&quot;的div元素</span><br><span class="line">var els = document.querySelectorAll(&quot;div.note, div.alert&quot;);</span><br><span class="line"></span><br><span class="line">// 获取元素</span><br><span class="line">var el = document.getElementById(&apos;xxx&apos;);</span><br><span class="line">var els = document.getElementsByClassName(&apos;highlight&apos;);</span><br><span class="line">var els = document.getElementsByTagName(&apos;td&apos;);</span><br></pre></td></tr></table></figure>
<p>另外，Element也提供了很多相对于元素的DOM导航方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取父元素、父节点</span><br><span class="line">var parent = ele.parentElement;</span><br><span class="line">var parent = ele.parentNode;</span><br><span class="line"></span><br><span class="line">// 获取子节点，子节点可以是任何一种节点，可以通过nodeType来判断</span><br><span class="line">var nodes = ele.children;    </span><br><span class="line"></span><br><span class="line">// 查询子元素</span><br><span class="line">var els = ele.getElementsByTagName(&apos;td&apos;);</span><br><span class="line">var els = ele.getElementsByClassName(&apos;highlight&apos;);</span><br><span class="line"></span><br><span class="line">eg：👇</span><br><span class="line">&lt;div class=&quot;test&quot; id=&quot;test&quot;&gt;</span><br><span class="line">　　&lt;p&gt;1&lt;/p&gt;</span><br><span class="line">　　&lt;p&gt;3&lt;/p&gt;</span><br><span class="line">　　&lt;p&gt;5&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">　　var a = document.getElementById(&quot;test&quot;);</span><br><span class="line">　　var b = a.childNodes;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">大家猜猜console.log(b)打印什么 一开始我以为就3个元素</span><br><span class="line">但是其实是【text,p,text,p,text,p，text】7个元素</span><br><span class="line">因为根据dom的标准，标签之间的回车空格等特殊字符属于文本节点，上面的div中输入了4个回车，因此会多出四个text节点：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 当前元素的第一个/最后一个子元素节点</span><br><span class="line">var el = ele.firstChild;</span><br><span class="line">var el = ele.firstElementChild;</span><br><span class="line"></span><br><span class="line">var el = ele.lastChild;</span><br><span class="line">var el = ele.lastElementChild;</span><br><span class="line"></span><br><span class="line">// 下一个/上一个兄弟元素节点</span><br><span class="line">var el = ele.nextSibling;</span><br><span class="line">var el = ele.nextElementSibling;</span><br><span class="line"></span><br><span class="line">var el = ele.previousSibling;</span><br><span class="line">var el = ele.previousElementSibling;</span><br></pre></td></tr></table></figure>


<h3 id="DOM-更改"><a href="#DOM-更改" class="headerlink" title="DOM 更改"></a>DOM 更改</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 添加、删除子元素</span><br><span class="line">ele.appendChild(el);</span><br><span class="line">ele.removeChild(el);</span><br><span class="line"></span><br><span class="line">// 替换子元素</span><br><span class="line">ele.replaceChild(el1, el2);</span><br><span class="line"></span><br><span class="line">// 插入子元素</span><br><span class="line">parentElement.insertBefore(newElement, referenceElement);</span><br></pre></td></tr></table></figure>

<h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 获取一个&#123;name, value&#125;的数组</span><br><span class="line">var attrs = el.attributes;</span><br><span class="line"></span><br><span class="line">// 获取、设置属性</span><br><span class="line">var c = el.getAttribute(&apos;class&apos;);</span><br><span class="line">el.setAttribute(&apos;class&apos;, &apos;highlight&apos;);</span><br><span class="line"></span><br><span class="line">// 判断、移除属性</span><br><span class="line">el.hasAttribute(&apos;class&apos;);</span><br><span class="line">el.removeAttribute(&apos;class&apos;);</span><br><span class="line"></span><br><span class="line">// 是否有属性设置</span><br><span class="line">el.hasAttributes();</span><br></pre></td></tr></table></figure>

<h3 id="常见的面试问题"><a href="#常见的面试问题" class="headerlink" title="常见的面试问题"></a>常见的面试问题</h3><p>innerHTML与outerHTML的区别？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">innerHTML输出结果：</span><br><span class="line"> </span><br><span class="line">&lt;h5&gt;就是喜欢你&lt;/h5&gt;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">outerHTML输出结果：</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;test&quot;&gt;&lt;h5&gt;就是喜欢你&lt;/h5&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>1.innerHTML 设置或获取位于对象起始和结束标签内的HTML<br>2.outerHTML设置或获取对象及其内容的HTML形式</p>
<p><a href="https://www.cnblogs.com/Nutrient-rich/p/7010317.html" target="_blank" rel="noopener">BomAPI</a></p>
<blockquote>
<ol>
<li>DOM 是 W3C 的标准； [所有浏览器公共遵守的标准]</li>
<li>BOM 是 各个浏览器厂商根据 DOM<br> 在各自浏览器上的实现;[表现为不同浏览器定义有差别,实现方式不同] </li>
<li>window 是 BOM 对象，而非 js 对象；</li>
</ol>
</blockquote>
<p><a href="https://www.jianshu.com/p/af0b398602bc" target="_blank" rel="noopener">vue核心之虚拟DOM(vdom)</a></p>
<p> 1-1 传统模板引擎<br>传统模板引擎编译生成HTML字符串。<br>通常在后台脚本语言中将模板和数据合并成html字符串输出到前端<br>或者后台输出数据，前端使用模板引擎组合数据和模板生成界面</p>
<p> 当数据发生变化的时候，最简单的就是模板重新渲染，或者模板引擎局部界面重新渲染。</p>
<p>当页面包含的数据很多的时候，这种代码操作中包含很多DOM操作，编码复杂不便维护。而且重新渲染导致性能问题</p>
<p>1-2 vdom<br>虚拟dom则将这个过程分为两步</p>
<p>第一步编译模板生成vdom的渲染函数render<br>在需要的渲染的时候调用渲染函数render组成的树状vdom</p>
<p>在mvvm数据绑定的结构中，将视图部分的渲染组织为vdom的渲染函数。可以优化编码结构与渲染效率</p>
<p><a href="https://blog.csdn.net/yczz/article/details/51516526" target="_blank" rel="noopener">VDom实现</a></p>
<p>👆看了之后您是否和我一样发生了如下化学反应</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模板语法???  不熟悉</span><br><span class="line">模板编译???  不懂  </span><br><span class="line">词法分析???  一脸懵逼  </span><br><span class="line">AST???  二脸懵逼</span><br><span class="line">使用js的正则表达式引擎实现词法分析?  三脸懵逼</span><br><span class="line">递归下降分析???  完全懵逼</span><br></pre></td></tr></table></figure>





<h3 id="Leecode"><a href="#Leecode" class="headerlink" title="Leecode"></a>Leecode</h3><p><a href="https://space.bilibili.com/327247876/channel/detail?cid=104442" target="_blank" rel="noopener">技术蛋老师de视频</a></p>
<h2 id="Day4（防抖节流-amp-Eventloop-amp-Vue、React原理-amp-Angular）"><a href="#Day4（防抖节流-amp-Eventloop-amp-Vue、React原理-amp-Angular）" class="headerlink" title="Day4（防抖节流&amp;Eventloop&amp;Vue、React原理&amp;Angular）"></a>Day4（防抖节流&amp;Eventloop&amp;Vue、React原理&amp;Angular）</h2><h3 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h3><p><a href="http://blog.zhencai.xyz/archives/20200501" target="_blank" rel="noopener">好兄弟整理的防抖节流</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/55511602" target="_blank" rel="noopener">Eventloop</a></p>
<h3 id="Vue和React原理"><a href="#Vue和React原理" class="headerlink" title="Vue和React原理"></a>Vue和React原理</h3><p><a href="https://www.bilibili.com/video/BV1ut4y1271C?t=411&p=6" target="_blank" rel="noopener">Vue和React原理</a></p>
<h3 id="为什么要使用组件？"><a href="#为什么要使用组件？" class="headerlink" title="为什么要使用组件？"></a>为什么要使用组件？</h3><p>将一个具备完整功能的项目的一部分进行多处使用</p>
<p>加快项目的进度</p>
<p>可以进行项目的复用</p>
<p>2、要想实现组件化，我们使用的这一部分必须是完整的，这个完整的整体称之为组件</p>
<p>vue将html、css、js、img等聚合体放在一起组成的文件称之为单文件组件，后缀名为vue（xxx.vue）</p>
<h3 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h3><p>一般认为，钩子函数就是回调函数的一种，其实还是有差异的，差异地方就是：触发的时机不同。</p>
<p>先说钩子函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let btn = document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.onclick = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;i&apos;m a hook&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子，在按钮点击时候立即执行钩子函数。而看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">btn.addEventListener(&quot;click&quot;,() =&gt;&#123;</span><br><span class="line">    console.log(this.onclick);//undefined</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>给btn绑定了一个监听器，只有消息捕获完成之后才能触发回调函数。</p>
<p>很明显的差别就是：钩子函数在捕获消息的第一时间就执行，而回调函数是捕获结束时，最后一个被执行的。</p>
<p>回调函数其实是调用者将回调函数的指针传递给了调用函数，当调用函数执行完毕后，通过函数指针来调用回调函数。而钩子函数在消息刚发出，没到达目的窗口前就先捕获了该消息，先得到控制权执行钩子函数，所以他可以加工改变该消息，当然也可以不作为，还可以强行结束该消息。</p>
<p>钩子（Hook）概念源于Windows的消息处理机制，通过设置钩子，应用程序对所有消息事件进行拦截，然后执行钩子函数。 </p>
<p><img src="http://q9uen5wtx.bkt.clouddn.com/vue_lifecycle-%E6%A0%87%E6%B3%A8%E7%89%88%E6%9C%AC.png" alt="vue官方生命周期图"></p>
<p>单个组件</p>
<ul>
<li>挂载阶段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeCreate</span><br><span class="line"></span><br><span class="line">在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</span><br><span class="line"></span><br><span class="line">created</span><br><span class="line"></span><br><span class="line">实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</span><br><span class="line"></span><br><span class="line">beforeMount</span><br><span class="line"></span><br><span class="line">在挂载开始之前被调用：相关的 render 函数首次被调用。</span><br><span class="line"></span><br><span class="line">mounted</span><br><span class="line"></span><br><span class="line">el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</span><br></pre></td></tr></table></figure>

<ul>
<li>更新阶段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeUpdate</span><br><span class="line"></span><br><span class="line">数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</span><br><span class="line"></span><br><span class="line">updated</span><br><span class="line"></span><br><span class="line">由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</span><br><span class="line"></span><br><span class="line">当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</span><br><span class="line"></span><br><span class="line">该钩子在服务器端渲染期间不被调用。</span><br></pre></td></tr></table></figure>

<ul>
<li>销毁阶段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeDestroy</span><br><span class="line"></span><br><span class="line">实例销毁之前调用。在这一步，实例仍然完全可用。</span><br><span class="line"></span><br><span class="line">destroyed</span><br><span class="line"></span><br><span class="line">Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</span><br></pre></td></tr></table></figure>
<h3 id="Vue怎么监听数据变化的"><a href="#Vue怎么监听数据变化的" class="headerlink" title="Vue怎么监听数据变化的"></a>Vue怎么监听数据变化的</h3><h5 id="利用keyup事件来实现"><a href="#利用keyup事件来实现" class="headerlink" title="利用keyup事件来实现"></a>利用keyup事件来实现</h5><p>在input标签里绑定keyup事件<br>定义一个函数getFullname：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;firstname&quot; @keyup=&quot;getFullname&quot;&gt; +</span><br><span class="line">   &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot; @keyup=&quot;getFullname&quot;&gt; =</span><br><span class="line">   &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>在vm中定义方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">     el: &apos;#app&apos;,</span><br><span class="line">     data: &#123;</span><br><span class="line">         firstname: &apos;&apos;,</span><br><span class="line">         lastname: &apos;&apos;,</span><br><span class="line">         fullname: &apos;&apos;</span><br><span class="line">     &#125;,</span><br><span class="line">     methods: &#123;</span><br><span class="line">         getFullname() &#123;</span><br><span class="line">             this.fullname = this.firstname + &apos;-&apos; + this.lastname</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>

<h5 id="使用watch"><a href="#使用watch" class="headerlink" title="使用watch"></a>使用watch</h5><p>watch和methods平级</p>
<p>** watch监听数据变化 **</p>
<p>使用这个 属性，可以监视 data 中指定数据的变化，然后触发这个 watch 中对应的 function 处理函数<br>该方法可以不用绑定事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt;+</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt;=</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">          firstname: &apos;&apos;,</span><br><span class="line">          lastname: &apos;&apos;,</span><br><span class="line">          fullname: &apos;&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;&#125;,</span><br><span class="line">      watch: &#123;</span><br><span class="line">          &apos;firstname&apos;: function(newVal)&#123;</span><br><span class="line">              this.fullname = newVal + &apos;-&apos; + this.lastname</span><br><span class="line">          &#125;,</span><br><span class="line">          &apos;lastname&apos;: function(newVal)&#123;</span><br><span class="line">              this.fullname = this.firstname + &apos;-&apos; + newVal</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">watch函数有两个变量，只是在该函数中有一个没有用上，写上也没有关系</span><br></pre></td></tr></table></figure>

<h5 id="computed计算属性的使用"><a href="#computed计算属性的使用" class="headerlink" title="computed计算属性的使用"></a>computed计算属性的使用</h5><p>在 computed 中，可以定义一些 属性，这些属性，叫做 【计算属性】， 计算属性的本质，就是 一个方法，只不过我们在使用 这些计算属性的时候，是把它们的名称直接当作属性来使用的；并不会把 计算属性当作方法去调用；<br>computed和methods平级</p>
<p>注意1： 计算属性，在引用的时候，一定不要加 () 去调用，直接把它当作普通 属性去使用就好了；</p>
<p>注意2： 只要 计算属性，这个 function 内部，所用到的 任何 data 中的数据发送了变化，就会立即重新计算 这个 计算属性的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt;+</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt;=</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">          firstname: &apos;&apos;,</span><br><span class="line">          lastname: &apos;&apos;,</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;&#125;,</span><br><span class="line">      watch: &#123;&#125;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">          &apos;fullname&apos;: function()&#123;</span><br><span class="line">              return this.firstname + &apos;-&apos; + this.lastname</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>注意：<br>1.fullname没有在data中定义<br>2.在compute定义fullname后直接return出去就好</p>
<p>注意3： 计算属性的求值结果，会被缓存起来，方便下次直接使用； 如果 计算属性方法中，所有的任何数据，都没有发生过变化，则不会重新对计算属性求值；</p>
<p>例：我们在fullname函数中定义输出一个ok，并且在主页中调用输出fullname</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt;+</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt;=</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;p&gt;&#123;&#123; fullname &#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123; fullname &#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123; fullname &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">          firstname: &apos;&apos;,</span><br><span class="line">          lastname: &apos;&apos;,</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;&#125;,</span><br><span class="line">      watch: &#123;&#125;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">          &apos;fullname&apos;: function()&#123;</span><br><span class="line">              console.log(&apos;ok&apos;)</span><br><span class="line">              return this.firstname + &apos;-&apos; + this.lastname</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p><strong>* 也就是说，不会因为页面中调用几次函数去执行几次，只会根据函数执行来调用函数 *</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 引入vue.js文件之后，会向全局暴露一个Vue构造器函数</span><br><span class="line">Vue.extend()是 vue 用来扩展 vue 功能（组件）的</span><br><span class="line">Vue.extend()实例化与new Vue()是一样的，几乎没有区别，所以借鉴react，vue决定组件要以标签的形式呈现</span><br><span class="line">为了符合html/html5的规则，所有组件的标签化使用必须先注册（即创建）</span><br><span class="line">说明白点注册就是将标签化的组件解析为html能识别的标签，因为自己创建的标签需要符合html规则，让html正确解析该组件标签</span><br><span class="line">组件必须先注册再使用，使用是在实例范围内使用</span><br><span class="line">组件名称可以小写加-命名 如：header-title</span><br><span class="line">大驼峰 如：GabrielLi 使用的时候写gabriel-li （注册的时候写的是大写，使用的时候写小写加-，因为浏览器会自动将大写解析成小写）</span><br><span class="line">一个单词大写，注意不要和原生的h5标签重名，比如 header footer</span><br></pre></td></tr></table></figure>




<h3 id="Vue-实现数据双向绑定的原理"><a href="#Vue-实现数据双向绑定的原理" class="headerlink" title="Vue 实现数据双向绑定的原理"></a>Vue 实现数据双向绑定的原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue实现数据双向绑定主要是：采用 数据劫持结合发布者-订阅者模式 的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回掉。当把一个普通 JavaScript 对象传给Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用Object.defineProperty 将他们转为 getter/setter。用户看不到getter / setter ，但是在内部它们让vue追踪依赖，在属性被访问和修改时通知变化。</span><br><span class="line"></span><br><span class="line">vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Complie 和 Watcher三者，通过Observer来监听自己的model的数据变化，通过Complie来解析编译模板指令(vue中是用来解析 &#123;&#123; &#125;&#125; ），最终利用watcher搭起observer和complie之间的通信桥梁，达到数据变化 ==》 视图更新，视图交互变化（input）==》 数据model变更双向绑定效果。</span><br><span class="line"></span><br><span class="line">js实现简单的双向绑定</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt;</span><br><span class="line">        &lt;p id=&quot;show&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var obj = &#123;&#125;;</span><br><span class="line">    Object.defineProperty(obj, &apos;txt&apos;, &#123;</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            return obj</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function (newValue) &#123;</span><br><span class="line">            document.getElementById(&apos;txt&apos;).value = newValue;</span><br><span class="line">            document.getElementById(&apos;show&apos;).innerHTML = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    document.addEventListener(&apos;keyup&apos;, function (ev) &#123;</span><br><span class="line">        obj.txt = ev.target.value;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>




<hr>
<h3 id="Vue-组件间的参数传递"><a href="#Vue-组件间的参数传递" class="headerlink" title="Vue 组件间的参数传递"></a>Vue 组件间的参数传递</h3><p>1.父组件与子组件传值<br>父组件传给子组件： 子组件通过props方法接受数据；<br>子组件传给父组件：$emit方法传递参数;<br>2.非父子组件间的数据传递，兄弟组件传值<br>EventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接受事件，项目比较小时，用这个比较合适；<br>VueX，创建一个数据仓库，整个项目全局都可以往这个仓库存放数据和读取数据</p>
<h3 id="Vue的路由实现：hash模式-和-history模式"><a href="#Vue的路由实现：hash模式-和-history模式" class="headerlink" title="Vue的路由实现：hash模式 和 history模式"></a>Vue的路由实现：hash模式 和 history模式</h3><p>hash模式： 在浏览器中符号 “#” 以及#后面的字符称之为hash，用window.location.hash读取；<br>特点：hash虽然在URL中，但不被包括在HTTP请求中，用来指导浏览器动作，对服务端安全无用，hash不会重新加载页面。</p>
<p>history模式：history 采用HTML5的新特性；且提供了两个新方法：pushState（）、replaceState（）可以对浏览器历史纪录栈进行修改，以及popState事件监听到状态变更。</p>
<h3 id="Vue与Angular以及React的区别？"><a href="#Vue与Angular以及React的区别？" class="headerlink" title="Vue与Angular以及React的区别？"></a>Vue与Angular以及React的区别？</h3><p>相同点：都支持指令，内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定，都不支持低端浏览器；</p>
<p>不同点：AngularJs的学习成本高，比如Dependency、Injecttion特性，而vue.js本身提供的API都比较简单、直观；在性能上，AngularJs依赖对数据做脏检查，所以watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所以的数据都是独立触发的。</p>
<h3 id="与React的区别"><a href="#与React的区别" class="headerlink" title="与React的区别"></a>与React的区别</h3><p>相同点：<br>React采用独特的JSX语法，Vue.js 在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用;中心实现相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化底去处理需求，都不内置列数Ajax，Route等功能到核心包，而是以插件的方式加载;在组件开发中都支持mixins的特性了；</p>
<p>不同点：<br>React采用Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷的操作Virtual DOM。</p>
<h3 id="Vue路由的钩子函数"><a href="#Vue路由的钩子函数" class="headerlink" title="Vue路由的钩子函数"></a>Vue路由的钩子函数</h3><p>首页可以控制导航跳转，beforeEach，afterEach等。一般用于页面title的修改，一些需要登录才能调整页面重定向功能。<br>beforeEach 主要的3个参数to，from，next；<br>to : route即将进入的目标路由对象、<br>from： route当前导航正要离开的路由、<br>next： function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转</p>
<h3 id="Vuex是什么？怎么使用？那种功能场景使用它？"><a href="#Vuex是什么？怎么使用？那种功能场景使用它？" class="headerlink" title="Vuex是什么？怎么使用？那种功能场景使用它？"></a>Vuex是什么？怎么使用？那种功能场景使用它？</h3><p>只要来读取的状态集中放在store中；改变状态的方式就是提交mutations。这是个同步的实物；异步逻辑应该封装中action中。<br>在main.js引入store，注入。新建一个目录store，…export。<br>场景有： 单页面应用，组件之间的状态，音乐播放，登录状态，加入购物车</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">state</span><br><span class="line">Vuex 使用单一状态树，既每个应用将仅仅包含一个store实例，单单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</span><br><span class="line">mutations</span><br><span class="line">mutations定义的方法动态修改Vuex的store中的状态或数据。</span><br><span class="line">getters</span><br><span class="line">类似vue的计算属性，主要用来过滤一些数据。</span><br><span class="line">action</span><br><span class="line">action可以理解为通过mutations里面处理数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view层通过store.dispath来分配action。</span><br></pre></td></tr></table></figure>

<h3 id="对Keep-Alive的了解？"><a href="#对Keep-Alive的了解？" class="headerlink" title="对Keep-Alive的了解？"></a>对Keep-Alive的了解？</h3><p>keep-alive 是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br>在vue 2.1.0的版本之后，keep-alive新加入了两个属性： include( 包含的组件缓存）与exclude(排除的组件不缓存，优先级大于include）<br>使用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;inclde_components&quot; exclude=&quot;exclude_components&quot;&gt;</span><br><span class="line">     &lt;component&gt;</span><br><span class="line">       &lt;!-- 该组件是否缓存取决与include 和 exclude 属性--&gt;</span><br><span class="line">     &lt;/component&gt;</span><br><span class="line"> &lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p>  参数解释<br>include – 字符串或者正则表达式，只要名称匹配的组件会被缓存<br>exclude – 字符串或者正则表达式，任何名称匹配的组件都不被缓存<br>include 和exclude 的属性允许组件有条件的缓存。而这都可以用 “ , “ 分割字符串、正则表达式、数组。单使用正则或者是数组是，要记得用 v-bind</p>
<h3 id="vue如何自己实现v-model"><a href="#vue如何自己实现v-model" class="headerlink" title="vue如何自己实现v-model"></a>vue如何自己实现v-model</h3><p>v-bind只能实现单向绑定</p>
<p>v-model（v-bind+触发的input事件）实现双向绑定</p>
<p>自定义表单输入组件</p>
<p>几个步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当有数据输入时触发了该组件的input事件</span><br><span class="line">手动触发父组件的input事件并将值传给父组件</span><br><span class="line">父组件的input事件被触发，将传来的值赋给父组件的变量price，实现输入框value到父元素的price的单向绑定</span><br><span class="line">父组件value的值绑定到price </span><br><span class="line">将父组件的value值通过props传递给子组件，实现了父组件的price到子组件value的单向绑定</span><br></pre></td></tr></table></figure>

<h3 id="Vue-nextTick-的原理和用途"><a href="#Vue-nextTick-的原理和用途" class="headerlink" title="Vue.nextTick 的原理和用途"></a>Vue.nextTick 的原理和用途</h3><p><a href="https://www.jianshu.com/p/7f9495b1c8ab" target="_blank" rel="noopener">Vue.nextTick 的原理和用途</a></p>
<p>原理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.异步说明</span><br><span class="line"></span><br><span class="line">Vue是异步渲染</span><br><span class="line"></span><br><span class="line">Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</span><br><span class="line"></span><br><span class="line">2.事件循环说明</span><br><span class="line"></span><br><span class="line">简单来说，Vue在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。</span><br><span class="line"></span><br><span class="line">$nextTick会在DOM渲染之后触发，以获取新的Dom节点</span><br></pre></td></tr></table></figure>

<h3 id="vue中的插槽————slot"><a href="#vue中的插槽————slot" class="headerlink" title="vue中的插槽————slot"></a>vue中的插槽————slot</h3><p>什么是插槽？<br>插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。<br>插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制</p>
<p><a href="https://www.cnblogs.com/loveyt/p/9946450.html" target="_blank" rel="noopener">怎么用slot</a></p>
<h3 id="vue-router核心实现原理"><a href="#vue-router核心实现原理" class="headerlink" title="vue-router核心实现原理"></a>vue-router核心实现原理</h3><p>目标：<br>1.实现一个静态install方法，因为作为插件都必须有这个方法，给Vue.use()去调用；<br>2.可以监听路由变化；<br>3.解析配置的路由，即解析router的配置项routes，能根据路由匹配到对应组件；<br>4.实现两个全局组件router-link和router-view；（最终落地点）</p>
<h3 id="Vue全家桶"><a href="#Vue全家桶" class="headerlink" title="Vue全家桶"></a>Vue全家桶</h3><h5 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h5><p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：</p>
<p>通过 @vue/cli 实现的交互式的项目脚手架。<br>通过 @vue/cli + @vue/cli-service-global 实现的零配置原型开发。<br>一个运行时依赖 (@vue/cli-service)，该依赖：<br>可升级；<br>基于 webpack 构建，并带有合理的默认配置；<br>可以通过项目内的配置文件进行配置；<br>可以通过插件进行扩展。<br>一个丰富的官方插件集合，集成了前端生态中最好的工具。<br>一套完全图形化的创建和管理 Vue.js 项目的用户界面。<br>Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需 eject。</p>
<h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p>Vuex是专门为Vue服务，用于管理页面的数据状态、提供统一数据操作的生态系统，相当于数据库mongoDB，MySQL等，任何组件都可以存取仓库中的数据。其中vuex类似的 还是有Redux,Redux大多用于React</p>
<p><strong>* 概念理解性 *</strong></p>
<p>Vuex采用MVC模式中的Model层，规定所有的数据必须通过action—&gt;mutaion—&gt;state这个流程进行来改变状态的。再结合Vue的数据视图双向绑定实现页面的更新。统一页面状态管理，可以让复杂的组件交互变的简单清晰，同时在调试时也可以通过DEVtools去查看状态。</p>
<p>在当前前端的spa模块化项目中不可避免的是某些变量需要在全局范围内引用，此时父子组件的传值，子父组件间的传值，兄弟组件间的传值成了我们需要解决的问题。虽然vue中提供了props（父传子）commit（子传父）兄弟间也可以用localstorage和sessionstorage。但是这种方式在项目开发中带来的问题比他解决的问题（难管理，难维护，代码复杂，安全性低）更多。vuex的诞生也是为了解决这些问题，从而大大提高我们vue项目的开发效率。</p>
<p><strong>* Vue双向绑定　*</strong></p>
<p>要说 Vuex 的双向绑定那么必须先从 Vue 的双向绑定开始</p>
<p>Vuex仅仅是Vue的一个插件。Vuex只能使用在vue上，因为其高度依赖于Vue的双向绑定和插件系统。</p>
<p>从Vue的源码来看，Vue的双向绑定主要做了2件事</p>
<p>数据劫持<br>添加观察者</p>
<p>数据劫持实现：（源码精简）<br>// 老版本通过 Object.defineProperty 递归可以实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 老版本通过 Object.defineProperty 递归可以实现</span><br><span class="line"></span><br><span class="line">// src/core/observer/index.js</span><br><span class="line">Object.defineProperty(obj, key, &#123;</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true,</span><br><span class="line">  get: function reactiveGetter () &#123;</span><br><span class="line">    const value = getter ? getter.call(obj) : val</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      dep.depend()</span><br><span class="line">      if (childOb) &#123;</span><br><span class="line">        childOb.dep.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      if (Array.isArray(value)) &#123;</span><br><span class="line">        dependArray(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return value</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function reactiveSetter (newVal) &#123;</span><br><span class="line">    const value = getter ? getter.call(obj) : val</span><br><span class="line">    if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    if (setter) &#123;</span><br><span class="line">      setter.call(obj, newVal)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">    childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">    dep.notify()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里无非就是劫持了对象的get和set方法。在所代理的属性的get方法中，当dep.Target存在的时候会调用 dep.depend()，</p>
<p>划重点：2行代码</p>
<p>Object.defineProperty<br>dep.depend()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 最新版可以通过 Proxy 实现</span><br><span class="line">Proxy(data, &#123;</span><br><span class="line">  get(target, key) &#123;</span><br><span class="line">    return target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, key, value) &#123;</span><br><span class="line">    let val = Reflect.set(target, key, value);</span><br><span class="line">      _that.$dep[key].forEach(item =&gt; item.update());</span><br><span class="line">    return val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>劫持了对象的get和set方法。</p>
<p>在数据劫持之外最重要的部分就是 Dep 和 Watcher,这其实是一个观察者模式。用最简单的代码实现以下 Vue 的观察者模式。</p>
<p>观察者模式实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 观察者</span><br><span class="line">    class Dep &#123;</span><br><span class="line">        constructor() &#123;</span><br><span class="line">            this.subs = []</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        addSub(sub) &#123;</span><br><span class="line">            this.subs.push(sub)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        depend() &#123;</span><br><span class="line">            if (Dep.target) &#123; </span><br><span class="line">                Dep.target.addDep(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        notify() &#123;</span><br><span class="line">            this.subs.forEach(sub =&gt; sub.update())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 被观察者</span><br><span class="line">    class Watcher &#123;</span><br><span class="line">        constructor(vm, expOrFn) &#123;</span><br><span class="line">            this.vm = vm;</span><br><span class="line">            this.getter = expOrFn;</span><br><span class="line">            this.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        get() &#123;</span><br><span class="line">            Dep.target = this;</span><br><span class="line">            </span><br><span class="line">            var vm = this.vm;</span><br><span class="line">            var value = this.getter.call(vm, vm);</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        evaluate() &#123;</span><br><span class="line">            this.value = this.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addDep(dep) &#123;</span><br><span class="line">            dep.addSub(this);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        update() &#123;</span><br><span class="line">            console.log(&apos;更新, value:&apos;, this.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 观察者实例</span><br><span class="line">    var dep = new Dep();</span><br><span class="line">    </span><br><span class="line">    //  被观察者实例</span><br><span class="line">    var watcher = new Watcher(&#123;x: 1&#125;, (val) =&gt; val);</span><br><span class="line">    watcher.evaluate();</span><br><span class="line">    </span><br><span class="line">    // 观察者监听被观察对象</span><br><span class="line">    dep.depend()</span><br><span class="line">    </span><br><span class="line">    dep.notify()</span><br></pre></td></tr></table></figure>



<p>3件事</p>
<p>1、通过 watcher.evaluate() 将自身实例赋值给 Dep.target</p>
<p>2、调用 dep.depend() 将dep实例将 watcher 实例 push 到 dep.subs中</p>
<p>3、通过数据劫持，在调用被劫持的对象的 set 方法时，调用 dep.subs 中所有的 watcher.update()</p>
<p>从此。双向绑定完成。通过 watcher.evaluate() 将自身实例赋值给 Dep.target<br>调用 dep.depend() 将dep实例将 watcher 实例 push 到 dep.subs中<br>通过数据劫持，在调用被劫持的对象的 set 方法时，调用 dep.subs 中所有的 watcher.update()<br>从此。双向绑定完成。</p>
<p>Vuex的注入代码比较简单，调用了一下applyMixin方法，现在的版本其实就是调用了Vue.mixin，在所有组件的 beforeCreate生命周期注入了设置 this.$store这样一个对象。</p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p><a href="https://segmentfault.com/a/1190000016344599" target="_blank" rel="noopener">Vue相关</a></p>
<p><a href="https://blog.csdn.net/li123128/article/details/102678464" target="_blank" rel="noopener">Object.defineProperty的缺陷</a></p>
<p><a href="https://www.cnblogs.com/wangxi01/p/11225555.html" target="_blank" rel="noopener">Object.defineProperty的缺陷</a></p>
<p><a href="https://blog.csdn.net/u014628388/article/details/81085605" target="_blank" rel="noopener">vue中通过watch监听数据变化，带来的性能优化</a></p>
<p><a href="https://segmentfault.com/a/1190000016885832?utm_source=tag-newest" target="_blank" rel="noopener">Reeact相关</a></p>
<h3 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h3><p><a href="https://www.bilibili.com/video/BV1bt411e71b?from=search&seid=16147648433792853331" target="_blank" rel="noopener">Angular9入门实战</a></p>
<h2 id="Day5（Node-js-amp-Ts-amp-数据可视化）"><a href="#Day5（Node-js-amp-Ts-amp-数据可视化）" class="headerlink" title="Day5（Node.js&amp;Ts&amp;数据可视化）"></a>Day5（Node.js&amp;Ts&amp;数据可视化）</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p><a href="http://nodejs.cn/api/assert.html" target="_blank" rel="noopener">Node.js文档</a></p>
<p><a href="https://www.bilibili.com/video/BV1bJ41187zA?from=search&seid=9359668186195464368" target="_blank" rel="noopener">node.js及项目工程化讲解</a></p>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p><a href="https://www.runoob.com/typescript/ts-tutorial.html" target="_blank" rel="noopener">TypeScript 教程</a></p>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p><a href="https://www.cnblogs.com/haore147/p/3860840.html" target="_blank" rel="noopener">十大可视化工具</a></p>
<p><a href="https://www.cnblogs.com/st-leslie/p/5771241.html" target="_blank" rel="noopener">Echarts.js</a></p>
<p><a href="https://www.echartsjs.com/zh/index.html" target="_blank" rel="noopener">Echarts文档</a></p>
<h2 id="Day6（算法笔记复习-amp-前端工程化的理解）"><a href="#Day6（算法笔记复习-amp-前端工程化的理解）" class="headerlink" title="Day6（算法笔记复习&amp;前端工程化的理解）"></a>Day6（算法笔记复习&amp;前端工程化的理解）</h2><h3 id="JS数据结构和算法"><a href="#JS数据结构和算法" class="headerlink" title="JS数据结构和算法"></a>JS数据结构和算法</h3><p><a href="https://www.bilibili.com/video/BV1f4411N7pn?t=210&p=2" target="_blank" rel="noopener">JS数据结构和算法</a></p>
<h3 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h3><p><a href="https://www.jianshu.com/p/88ed70476adb" target="_blank" rel="noopener">前端工程化的理解</a></p>
<p><a href="https://blog.csdn.net/valada/article/details/93981009" target="_blank" rel="noopener">什么是前端工程化？</a></p>
<h2 id="Day7-实战"><a href="#Day7-实战" class="headerlink" title="Day7 (实战)"></a>Day7 (实战)</h2><p><a href="https://www.infoq.cn/article/how-to-design-a-small-and-beautiful-spike-system/" target="_blank" rel="noopener">设计一个抢购页面(小而美)</a></p>
<p><a href="https://blog.csdn.net/aa19891204/article/details/82955912" target="_blank" rel="noopener">利用redis+mysql实现简单的秒杀系统</a></p>
<p><a href="https://blog.csdn.net/qq_32766999/article/details/100734531" target="_blank" rel="noopener">给1000个li绑定点击事件</a></p>
<p><a href="https://www.cnblogs.com/yangsg/p/10606553.html" target="_blank" rel="noopener">给1000个li绑定点击事件</a></p>
<p>方法一：for循环 ：给每个li定义一个属性索引值 、itemli[i].onclick、</p>
<p>方法二：JS事件代理  (event.target 属性可以用来实现事件委托 (event delegation)。)</p>
<p><a href="https://www.jianshu.com/p/a77d8928c5c9" target="_blank" rel="noopener">简述JS中的事件委托和事件代理</a></p>
<p>什么是事件委托：通俗的讲，事件就是onclick，onmouseover，onmouseout，等就是事件，委托呢，就是让别人来做，这个事件本来是加在某些元素上的，然而你却加到别人身上来做，完成这个事件。</p>
<p>也就是：利用冒泡的原理，把事件加到父级上，触发执行效果。</p>
<p>好处呢：1，提高性能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"> </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;事件委托&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;ul id=&quot;ulItem&quot;&gt;</span><br><span class="line">&lt;li id=&quot;li1&quot;&gt;1&lt;/li&gt;</span><br><span class="line">&lt;li id=&quot;li2&quot;&gt;2&lt;/li&gt;</span><br><span class="line">&lt;li id=&quot;li3&quot;&gt;3&lt;/li&gt;</span><br><span class="line">&lt;li id=&quot;li4&quot;&gt;4&lt;/li&gt;</span><br><span class="line">&lt;li id=&quot;li5&quot;&gt;5&lt;/li&gt;</span><br><span class="line">&lt;li id=&quot;li6&quot;&gt;6&lt;/li&gt;</span><br><span class="line">&lt;li id=&quot;li7&quot;&gt;7&lt;/li&gt;</span><br><span class="line">&lt;li id=&quot;li8&quot;&gt;8&lt;/li&gt;</span><br><span class="line">&lt;li id=&quot;li9&quot;&gt;9&lt;/li&gt;</span><br><span class="line">&lt;li id=&quot;li10&quot;&gt;10&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt; </span><br><span class="line">var ulItem = document.getElementById(&quot;ulItem&quot;);</span><br><span class="line">ulItem.onclick = function(e)&#123;</span><br><span class="line">e = e || window.event;//这一行及下一行是为兼容IE8及以下版本</span><br><span class="line">var target = e.target || e.srcElement;</span><br><span class="line">//target.tagName.toLowerCase()取得触发事件的当前对象</span><br><span class="line">if(target.tagName.toLowerCase() === &quot;li&quot;)&#123;</span><br><span class="line">alert(target.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt; </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ul = document.querySelector(&quot;ul&quot;);</span><br><span class="line">　　ulItem.onclick = function (e) &#123;</span><br><span class="line">　　e = e || window.event; //这一行及下一行是为兼容IE8及以下版本</span><br><span class="line">　　var target = e.target || e.srcElement;</span><br><span class="line">　　if (target.tagName.toLowerCase() === &quot;li&quot;) &#123;</span><br><span class="line">　　　　var li = this.querySelectorAll(&quot;li&quot;);</span><br><span class="line">　　　　index = Array.prototype.indexOf.call(li, target);</span><br><span class="line">　　　　alert(target.innerHTML + index);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/Leadyang/article/details/80639278" target="_blank" rel="noopener">设计一个贪吃蛇小游戏</a></p>
<p><a href="https://jingyan.baidu.com/article/77b8dc7fa8eac06174eab6b4.html" target="_blank" rel="noopener">js设计一个五子棋游戏</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>vue</title>
    <url>/2020/05/02/page/</url>
    <content><![CDATA[<h3 id="Vue-实现数据双向绑定的原理"><a href="#Vue-实现数据双向绑定的原理" class="headerlink" title="Vue 实现数据双向绑定的原理"></a>Vue 实现数据双向绑定的原理</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue实现数据双向绑定主要是：采用 数据劫持结合发布者-订阅者模式 的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回掉。当把一个普通 JavaScript 对象传给Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用Object.defineProperty 将他们转为 getter/setter。用户看不到getter / setter ，但是在内部它们让vue追踪依赖，在属性被访问和修改时通知变化。</span><br><span class="line"></span><br><span class="line">vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Complie 和 Watcher三者，通过Observer来监听自己的model的数据变化，通过Complie来解析编译模板指令(vue中是用来解析 &#123;&#123; &#125;&#125; ），最终利用watcher搭起observer和complie之间的通信桥梁，达到数据变化 ==》 视图更新，视图交互变化（input）==》 数据model变更双向绑定效果。</span><br><span class="line"></span><br><span class="line">js实现简单的双向绑定</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt;</span><br><span class="line">        &lt;p id=&quot;show&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var obj = &#123;&#125;;</span><br><span class="line">    Object.defineProperty(obj, &apos;txt&apos;, &#123;</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            return obj</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function (newValue) &#123;</span><br><span class="line">            document.getElementById(&apos;txt&apos;).value = newValue;</span><br><span class="line">            document.getElementById(&apos;show&apos;).innerHTML = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    document.addEventListener(&apos;keyup&apos;, function (ev) &#123;</span><br><span class="line">        obj.txt = ev.target.value;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>




<hr>
<h3 id="Vue-组件间的参数传递"><a href="#Vue-组件间的参数传递" class="headerlink" title="Vue 组件间的参数传递"></a>Vue 组件间的参数传递</h3><p>1.父组件与子组件传值<br>父组件传给子组件： 子组件通过props方法接受数据；<br>子组件传给父组件：$emit方法传递参数;<br>2.非父子组件间的数据传递，兄弟组件传值<br>EventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接受事件，项目比较小时，用这个比较合适；<br>VueX，创建一个数据仓库，整个项目全局都可以往这个仓库存放数据和读取数据</p>
<h3 id="Vue的路由实现：hash模式-和-history模式"><a href="#Vue的路由实现：hash模式-和-history模式" class="headerlink" title="Vue的路由实现：hash模式 和 history模式"></a>Vue的路由实现：hash模式 和 history模式</h3><p>hash模式： 在浏览器中符号 “#” 以及#后面的字符称之为hash，用window.location.hash读取；<br>特点：hash虽然在URL中，但不被包括在HTTP请求中，用来指导浏览器动作，对服务端安全无用，hash不会重新加载页面。</p>
<p>history模式：history 采用HTML5的新特性；且提供了两个新方法：pushState（）、replaceState（）可以对浏览器历史纪录栈进行修改，以及popState事件监听到状态变更。</p>
<h3 id="Vue与Angular以及React的区别？"><a href="#Vue与Angular以及React的区别？" class="headerlink" title="Vue与Angular以及React的区别？"></a>Vue与Angular以及React的区别？</h3><p>相同点：都支持指令，内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定，都不支持低端浏览器；</p>
<p>不同点：AngularJs的学习成本高，比如Dependency、Injecttion特性，而vue.js本身提供的API都比较简单、直观；在性能上，AngularJs依赖对数据做脏检查，所以watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所以的数据都是独立触发的。</p>
<h3 id="与React的区别"><a href="#与React的区别" class="headerlink" title="与React的区别"></a>与React的区别</h3><p>相同点：<br>React采用独特的JSX语法，Vue.js 在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用;中心实现相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化底去处理需求，都不内置列数Ajax，Route等功能到核心包，而是以插件的方式加载;在组件开发中都支持mixins的特性了；</p>
<p>不同点：<br>React采用Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷的操作Virtual DOM。</p>
<h3 id="Vue路由的钩子函数"><a href="#Vue路由的钩子函数" class="headerlink" title="Vue路由的钩子函数"></a>Vue路由的钩子函数</h3><p>首页可以控制导航跳转，beforeEach，afterEach等。一般用于页面title的修改，一些需要登录才能调整页面重定向功能。<br>beforeEach 主要的3个参数to，from，next；<br>to : route即将进入的目标路由对象、<br>from： route当前导航正要离开的路由、<br>next： function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转</p>
<h3 id="Vuex是什么？怎么使用？那种功能场景使用它？"><a href="#Vuex是什么？怎么使用？那种功能场景使用它？" class="headerlink" title="Vuex是什么？怎么使用？那种功能场景使用它？"></a>Vuex是什么？怎么使用？那种功能场景使用它？</h3><p>只要来读取的状态集中放在store中；改变状态的方式就是提交mutations。这是个同步的实物；异步逻辑应该封装中action中。<br>在main.js引入store，注入。新建一个目录store，…export。<br>场景有： 单页面应用，组件之间的状态，音乐播放，登录状态，加入购物车</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">state</span><br><span class="line">Vuex 使用单一状态树，既每个应用将仅仅包含一个store实例，单单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</span><br><span class="line">mutations</span><br><span class="line">mutations定义的方法动态修改Vuex的store中的状态或数据。</span><br><span class="line">getters</span><br><span class="line">类似vue的计算属性，主要用来过滤一些数据。</span><br><span class="line">action</span><br><span class="line">action可以理解为通过mutations里面处理数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view层通过store.dispath来分配action。</span><br></pre></td></tr></table></figure>

<h3 id="对Keep-Alive的了解？"><a href="#对Keep-Alive的了解？" class="headerlink" title="对Keep-Alive的了解？"></a>对Keep-Alive的了解？</h3><p>keep-alive 是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br>在vue 2.1.0的版本之后，keep-alive新加入了两个属性： include( 包含的组件缓存）与exclude(排除的组件不缓存，优先级大于include）<br>使用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;inclde_components&quot; exclude=&quot;exclude_components&quot;&gt;</span><br><span class="line">     &lt;component&gt;</span><br><span class="line">       &lt;!-- 该组件是否缓存取决与include 和 exclude 属性--&gt;</span><br><span class="line">     &lt;/component&gt;</span><br><span class="line"> &lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p>  参数解释<br>include – 字符串或者正则表达式，只要名称匹配的组件会被缓存<br>exclude – 字符串或者正则表达式，任何名称匹配的组件都不被缓存<br>include 和exclude 的属性允许组件有条件的缓存。而这都可以用 “ , “ 分割字符串、正则表达式、数组。单使用正则或者是数组是，要记得用 v-bind</p>
<h3 id="vue如何自己实现v-model"><a href="#vue如何自己实现v-model" class="headerlink" title="vue如何自己实现v-model"></a>vue如何自己实现v-model</h3><p>v-bind只能实现单向绑定</p>
<p>v-model（v-bind+触发的input事件）实现双向绑定</p>
<p>自定义表单输入组件</p>
<p>几个步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当有数据输入时触发了该组件的input事件</span><br><span class="line">手动触发父组件的input事件并将值传给父组件</span><br><span class="line">父组件的input事件被触发，将传来的值赋给父组件的变量price，实现输入框value到父元素的price的单向绑定</span><br><span class="line">父组件value的值绑定到price </span><br><span class="line">将父组件的value值通过props传递给子组件，实现了父组件的price到子组件value的单向绑定</span><br></pre></td></tr></table></figure>

<h3 id="Vue-nextTick-的原理和用途"><a href="#Vue-nextTick-的原理和用途" class="headerlink" title="Vue.nextTick 的原理和用途"></a>Vue.nextTick 的原理和用途</h3><p><a href="https://www.jianshu.com/p/7f9495b1c8ab" target="_blank" rel="noopener">Vue.nextTick 的原理和用途</a></p>
<p>原理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.异步说明</span><br><span class="line"></span><br><span class="line">Vue是异步渲染</span><br><span class="line"></span><br><span class="line">Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</span><br><span class="line"></span><br><span class="line">2.事件循环说明</span><br><span class="line"></span><br><span class="line">简单来说，Vue在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。</span><br><span class="line"></span><br><span class="line">$nextTick会在DOM渲染之后触发，以获取新的Dom节点</span><br></pre></td></tr></table></figure>

<h3 id="vue中的插槽————slot"><a href="#vue中的插槽————slot" class="headerlink" title="vue中的插槽————slot"></a>vue中的插槽————slot</h3><p>什么是插槽？<br>插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。<br>插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制</p>
<p><a href="https://www.cnblogs.com/loveyt/p/9946450.html" target="_blank" rel="noopener">怎么用slot</a></p>
<h3 id="vue-router核心实现原理"><a href="#vue-router核心实现原理" class="headerlink" title="vue-router核心实现原理"></a>vue-router核心实现原理</h3><p>目标：<br>1.实现一个静态install方法，因为作为插件都必须有这个方法，给Vue.use()去调用；<br>2.可以监听路由变化；<br>3.解析配置的路由，即解析router的配置项routes，能根据路由匹配到对应组件；<br>4.实现两个全局组件router-link和router-view；（最终落地点）</p>
<h3 id="Vue全家桶"><a href="#Vue全家桶" class="headerlink" title="Vue全家桶"></a>Vue全家桶</h3><h5 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h5><p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：</p>
<p>通过 @vue/cli 实现的交互式的项目脚手架。<br>通过 @vue/cli + @vue/cli-service-global 实现的零配置原型开发。<br>一个运行时依赖 (@vue/cli-service)，该依赖：<br>可升级；<br>基于 webpack 构建，并带有合理的默认配置；<br>可以通过项目内的配置文件进行配置；<br>可以通过插件进行扩展。<br>一个丰富的官方插件集合，集成了前端生态中最好的工具。<br>一套完全图形化的创建和管理 Vue.js 项目的用户界面。<br>Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需 eject。</p>
<h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p>Vuex是专门为Vue服务，用于管理页面的数据状态、提供统一数据操作的生态系统，相当于数据库mongoDB，MySQL等，任何组件都可以存取仓库中的数据。其中vuex类似的 还是有Redux,Redux大多用于React</p>
<p><strong>* 概念理解性 *</strong></p>
<p>Vuex采用MVC模式中的Model层，规定所有的数据必须通过action—&gt;mutaion—&gt;state这个流程进行来改变状态的。再结合Vue的数据视图双向绑定实现页面的更新。统一页面状态管理，可以让复杂的组件交互变的简单清晰，同时在调试时也可以通过DEVtools去查看状态。</p>
<p>在当前前端的spa模块化项目中不可避免的是某些变量需要在全局范围内引用，此时父子组件的传值，子父组件间的传值，兄弟组件间的传值成了我们需要解决的问题。虽然vue中提供了props（父传子）commit（子传父）兄弟间也可以用localstorage和sessionstorage。但是这种方式在项目开发中带来的问题比他解决的问题（难管理，难维护，代码复杂，安全性低）更多。vuex的诞生也是为了解决这些问题，从而大大提高我们vue项目的开发效率。</p>
<p><strong>* Vue双向绑定　*</strong></p>
<p>要说 Vuex 的双向绑定那么必须先从 Vue 的双向绑定开始</p>
<p>Vuex仅仅是Vue的一个插件。Vuex只能使用在vue上，因为其高度依赖于Vue的双向绑定和插件系统。</p>
<p>从Vue的源码来看，Vue的双向绑定主要做了2件事</p>
<p>数据劫持<br>添加观察者</p>
<p>数据劫持实现：（源码精简）<br>// 老版本通过 Object.defineProperty 递归可以实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 老版本通过 Object.defineProperty 递归可以实现</span><br><span class="line"></span><br><span class="line">// src/core/observer/index.js</span><br><span class="line">Object.defineProperty(obj, key, &#123;</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true,</span><br><span class="line">  get: function reactiveGetter () &#123;</span><br><span class="line">    const value = getter ? getter.call(obj) : val</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      dep.depend()</span><br><span class="line">      if (childOb) &#123;</span><br><span class="line">        childOb.dep.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      if (Array.isArray(value)) &#123;</span><br><span class="line">        dependArray(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return value</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function reactiveSetter (newVal) &#123;</span><br><span class="line">    const value = getter ? getter.call(obj) : val</span><br><span class="line">    if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    if (setter) &#123;</span><br><span class="line">      setter.call(obj, newVal)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">    childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">    dep.notify()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里无非就是劫持了对象的get和set方法。在所代理的属性的get方法中，当dep.Target存在的时候会调用 dep.depend()，</p>
<p>划重点：2行代码</p>
<p>Object.defineProperty<br>dep.depend()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 最新版可以通过 Proxy 实现</span><br><span class="line">Proxy(data, &#123;</span><br><span class="line">  get(target, key) &#123;</span><br><span class="line">    return target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, key, value) &#123;</span><br><span class="line">    let val = Reflect.set(target, key, value);</span><br><span class="line">      _that.$dep[key].forEach(item =&gt; item.update());</span><br><span class="line">    return val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>劫持了对象的get和set方法。</p>
<p>在数据劫持之外最重要的部分就是 Dep 和 Watcher,这其实是一个观察者模式。用最简单的代码实现以下 Vue 的观察者模式。</p>
<p>观察者模式实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 观察者</span><br><span class="line">    class Dep &#123;</span><br><span class="line">        constructor() &#123;</span><br><span class="line">            this.subs = []</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        addSub(sub) &#123;</span><br><span class="line">            this.subs.push(sub)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        depend() &#123;</span><br><span class="line">            if (Dep.target) &#123; </span><br><span class="line">                Dep.target.addDep(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        notify() &#123;</span><br><span class="line">            this.subs.forEach(sub =&gt; sub.update())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 被观察者</span><br><span class="line">    class Watcher &#123;</span><br><span class="line">        constructor(vm, expOrFn) &#123;</span><br><span class="line">            this.vm = vm;</span><br><span class="line">            this.getter = expOrFn;</span><br><span class="line">            this.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        get() &#123;</span><br><span class="line">            Dep.target = this;</span><br><span class="line">            </span><br><span class="line">            var vm = this.vm;</span><br><span class="line">            var value = this.getter.call(vm, vm);</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        evaluate() &#123;</span><br><span class="line">            this.value = this.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addDep(dep) &#123;</span><br><span class="line">            dep.addSub(this);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        update() &#123;</span><br><span class="line">            console.log(&apos;更新, value:&apos;, this.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 观察者实例</span><br><span class="line">    var dep = new Dep();</span><br><span class="line">    </span><br><span class="line">    //  被观察者实例</span><br><span class="line">    var watcher = new Watcher(&#123;x: 1&#125;, (val) =&gt; val);</span><br><span class="line">    watcher.evaluate();</span><br><span class="line">    </span><br><span class="line">    // 观察者监听被观察对象</span><br><span class="line">    dep.depend()</span><br><span class="line">    </span><br><span class="line">    dep.notify()</span><br></pre></td></tr></table></figure>



<p>3件事</p>
<p>1、通过 watcher.evaluate() 将自身实例赋值给 Dep.target</p>
<p>2、调用 dep.depend() 将dep实例将 watcher 实例 push 到 dep.subs中</p>
<p>3、通过数据劫持，在调用被劫持的对象的 set 方法时，调用 dep.subs 中所有的 watcher.update()</p>
<p>从此。双向绑定完成。通过 watcher.evaluate() 将自身实例赋值给 Dep.target<br>调用 dep.depend() 将dep实例将 watcher 实例 push 到 dep.subs中<br>通过数据劫持，在调用被劫持的对象的 set 方法时，调用 dep.subs 中所有的 watcher.update()<br>从此。双向绑定完成。</p>
<p>Vuex的注入代码比较简单，调用了一下applyMixin方法，现在的版本其实就是调用了Vue.mixin，在所有组件的 beforeCreate生命周期注入了设置 this.$store这样一个对象。</p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot统一响应体（基于lombok）</title>
    <url>/2020/05/11/pringBoot%E7%BB%9F%E4%B8%80%E5%93%8D%E5%BA%94%E4%BD%93%EF%BC%88%E5%9F%BA%E4%BA%8Elombok%EF%BC%89/</url>
    <content><![CDATA[<p>抽点时间总结一下springBoot统一响应体，感觉以后会比较常用吧<br>由于是写给后端技术比较菜的（自己），所以会比较细，方便复习和理解。</p>
<a id="more"></a>

<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>1.HTTP状态码无法很好地表示业务中遇到的异常情况，通过修改响应返回的JSON数据，让其带上一些固有的字段</p>
<p>关键属性：</p>
<ul>
<li>code为返回结果的状态码</li>
<li>msg为返回结果的消息</li>
<li>data为返回的业务数据</li>
</ul>
<p>2.不限制返回类型，返回的响应都有统一的响应格式</p>
<p>3.代替基于AOP的实现方案（通过切面表达式+注解控制切点的Controller）<br>基于注解，而不需要修改AOP切面表达式。</p>
<h3 id="方案思路"><a href="#方案思路" class="headerlink" title="方案思路"></a>方案思路</h3><p>选择使用Spring的Controller增强机制，其中关键的类为以下3个：</p>
<ul>
<li>@ControllerAdvice：类注解，用于指定Controller增强处理器类。</li>
<li>ResponseBodyAdvice：接口，实现后beforeBodyWrite()方法后可以对响应的body进行修改，需要结合@ControllerAdvice使用。</li>
<li>@ExceptionHandler：方法注解，用于指定异常处理方法，需要结合@ControllerAdvice和@ResponseBody使用。</li>
</ul>
<p>为了提高生产效率不做重复工作，这里再介绍一下Lombok</p>
<p>lombok 提供了简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 java 代码。通过使用对应的注解，可以在编译源码的时候生成对应的方法，所以不会影响任何运行效率。</p>
<p>用到如下注解：</p>
<ul>
<li>@Slf4j ：注解在类上；根据用户实际使用的日志框架生成log日志对象。</li>
<li>@Data<br>使用这个注解，就不用再去手写Getter,Setter,equals,canEqual,hasCode,toString等方法了，注解后在编译时会自动加进去。</li>
<li>@AllArgsConstructor<br>使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数</li>
<li>@NoArgsConstructor<br>使用后创建一个无参构造函数</li>
<li>@Builder<br>关于Builder较为复杂一些，Builder的作用之一是为了解决在某个类有很多构造函数的情况，也省去写很多构造函数的麻烦，在设计模式中的思想是：用一个内部类去实例化一个对象，避免一个类出现过多构造函数，</li>
</ul>
<p>使用lombok可能会遇到注解失效的问题（我就遇到了）<br><a href="https://blog.csdn.net/qq_35868412/article/details/93137304" target="_blank" rel="noopener">解决办法</a></p>
<p>再推荐个给用eclipise 的工具：OpenExplorer<a href="https://github.com/samsonw/OpenExplorer/downloads" target="_blank" rel="noopener">点我下载最新版</a></p>
<p>放到eclipise的 plugins文件夹里，重启就可以用了</p>
<h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--web-starter--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--lombok--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--test-starter--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Controller增强后统一响应体对应的对象"><a href="#Controller增强后统一响应体对应的对象" class="headerlink" title="Controller增强后统一响应体对应的对象"></a>Controller增强后统一响应体对应的对象</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.springboot.response;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class ResponseResult implements Serializable&#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">     * 返回的状态码</span><br><span class="line">     */</span><br><span class="line">    private Integer code;</span><br><span class="line">    /**</span><br><span class="line">     * 返回的信息</span><br><span class="line">     */</span><br><span class="line">    private String msg;</span><br><span class="line">    /**</span><br><span class="line">     * 返回的数据</span><br><span class="line">     */</span><br><span class="line">    private Object data;</span><br><span class="line"></span><br><span class="line">	public ResponseResult(Integer code2, String msg2, Object body) &#123;</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">		this.code=code2;</span><br><span class="line">		this.msg = msg2;</span><br><span class="line">		this.data = body;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="统一响应注解-是否开启统一响应增强的注解"><a href="#统一响应注解-是否开启统一响应增强的注解" class="headerlink" title="统一响应注解 (是否开启统一响应增强的注解)"></a>统一响应注解 (是否开启统一响应增强的注解)</h4><p>添加注解后，统一响应体才能生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.springboot.response;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">//统一响应注解--自定义注解。</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)  //运行时生效</span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) // 用于描述注解的使用范围</span><br><span class="line">public @interface BaseResponse &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="状态码枚举"><a href="#状态码枚举" class="headerlink" title="状态码枚举"></a>状态码枚举</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum ResponseCode &#123;</span><br><span class="line">SUCCESS(100, &quot;success&quot;),</span><br><span class="line">RESOURCES_NOT_EXIST(101, &quot;资源不存在&quot;),</span><br><span class="line">//看业务来吧</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>最好补补基础有助于理解代码<br><a href="https://baijiahao.baidu.com/s?id=1660216833170469764&wfr=spider&for=pc" target="_blank" rel="noopener">Java基础之异常处理机制</a></p>
<h4 id="业务异常类"><a href="#业务异常类" class="headerlink" title="业务异常类"></a>业务异常类</h4><p>业务异常类是用于识别业务相关的异常，<br>异常类强制需要以ResponseCode作为构造方法入参，这样可以通过捕获异常获得返回的状态码信息</p>
<p>关于这块需要重点理解</p>
<p>否则会出现明明一切正常，返回结果确是异常的返回体。<br>比如我就遇到了👇<br>NullPointerException：空指针异常，一般当对象为null的时候，对该对象做操作时会出现该异常；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.springboot.errorhandle.exception;</span><br><span class="line"></span><br><span class="line">import com.springboot.response.ResponseCode;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.EqualsAndHashCode;</span><br><span class="line"></span><br><span class="line">// 业务异常类，继承运行时异常，确保事务正常回滚</span><br><span class="line">@Data</span><br><span class="line">@EqualsAndHashCode(callSuper = false)</span><br><span class="line">public class BaseException extends RuntimeException&#123;</span><br><span class="line"></span><br><span class="line">    private ResponseCode code;</span><br><span class="line"></span><br><span class="line">    public BaseException(ResponseCode code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BaseException(Throwable cause, ResponseCode code) &#123;</span><br><span class="line">        super(cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.springboot.errorhandle.exception;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">import com.springboot.response.BaseResponse;</span><br><span class="line">import com.springboot.response.ResponseCode;</span><br><span class="line">import com.springboot.response.ResponseResult;</span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异常处理器</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line">@ControllerAdvice(annotations = BaseResponse.class)</span><br><span class="line">@ResponseBody</span><br><span class="line">@Slf4j</span><br><span class="line">public class ExceptionHandlerAdvice &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 处理未捕获的Exception</span><br><span class="line">     * @param e 异常</span><br><span class="line">     * @return 统一响应体</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public ResponseResult handleException(Exception e)&#123;</span><br><span class="line">//        log.error(e.getMessage(),e);</span><br><span class="line">    	System.out.println(e.getMessage());</span><br><span class="line">    	System.out.println(e);</span><br><span class="line">    	System.out.println(&quot;3&quot;);</span><br><span class="line">        return new ResponseResult(ResponseCode.SERVICE_ERROR.getCode(),ResponseCode.SERVICE_ERROR.getMsg(),null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理未捕获的RuntimeException</span><br><span class="line">     * @param e 运行时异常</span><br><span class="line">     * @return 统一响应体</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(RuntimeException.class)</span><br><span class="line">    public ResponseResult handleRuntimeException(RuntimeException e)&#123;</span><br><span class="line">//        log.error(e.getMessage(),e);</span><br><span class="line">    	System.out.println(&quot;2&quot;);</span><br><span class="line">        return new ResponseResult(ResponseCode.SERVICE_ERROR.getCode(),ResponseCode.SERVICE_ERROR.getMsg(),null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理业务异常BaseException</span><br><span class="line">     * @param e 业务异常</span><br><span class="line">     * @return 统一响应体</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(CustomException.class)</span><br><span class="line">    public ResponseResult handleBaseException(CustomException e)&#123;</span><br><span class="line">//        log.error(e.getMessage(),e);</span><br><span class="line">        ResponseCode code=e.getCode();</span><br><span class="line">        System.out.println(&quot;1&quot;);</span><br><span class="line">        return new ResponseResult(code.getCode(),code.getMsg(),null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="ControllerAdvice"></a>ControllerAdvice</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.springboot.advice;</span><br><span class="line"></span><br><span class="line">import org.springframework.core.MethodParameter;</span><br><span class="line">import org.springframework.http.server.ServerHttpRequest;</span><br><span class="line">import org.springframework.http.server.ServerHttpResponse;</span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;</span><br><span class="line"></span><br><span class="line">import com.springboot.response.BaseResponse;</span><br><span class="line">import com.springboot.response.ResponseCode;</span><br><span class="line">import com.springboot.response.ResponseResult;</span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.springframework.http.MediaType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//如果全部异常处理都返回json，那么可以使用 @RestControllerAdvice 代替 @ControllerAdvice </span><br><span class="line">//这样在方法上就可以不需要添加 @ResponseBody。@RestControllerAdvice在注解上已经添加了@ResponseBody。</span><br><span class="line"></span><br><span class="line">//注：ControllerAdvice注解 只拦截Controller 不回拦截 Interceptor的异常</span><br><span class="line">@ControllerAdvice(annotations = BaseResponse.class)</span><br><span class="line">@Slf4j</span><br><span class="line">public class ResponseResultHandlerAdvice implements ResponseBodyAdvice&#123;</span><br><span class="line">	</span><br><span class="line">	private static final String logExceptionFormat = &quot;Capture Exception By GlobalExceptionHandler: Code: %s Detail: %s&quot;;</span><br><span class="line">    private static Logger log = LoggerFactory.getLogger(ResponseResultHandlerAdvice.class);</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">    public boolean supports(MethodParameter returnType, Class converterType) &#123;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object beforeBodyWrite(Object body, MethodParameter returnType,</span><br><span class="line">			org.springframework.http.MediaType selectedContentType, Class selectedConverterType,</span><br><span class="line">			ServerHttpRequest request, ServerHttpResponse response) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		 if(body instanceof ResponseResult)&#123; // 如果响应返回的对象为统一响应体，则直接返回body</span><br><span class="line"></span><br><span class="line">             return body;</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">             // 只有正常返回的结果才会进入这个判断流程，所以返回正常成功的状态码</span><br><span class="line">             ResponseResult responseResult =new ResponseResult(ResponseCode.SUCCESS.getCode(),ResponseCode.SUCCESS.getMsg(),body);</span><br><span class="line">			 System.out.println(&quot;return responseResult&quot;);</span><br><span class="line">             return responseResult;</span><br><span class="line">         &#125;</span><br><span class="line">		</span><br><span class="line">     </span><br><span class="line">     // 非JSON格式body直接返回即可</span><br><span class="line">//     return body;</span><br><span class="line">	&#125; </span><br><span class="line">	  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok 这样我们在需要统一返回体的controller中加入@BaseResponse<br>就可以啦</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@BaseResponse</span><br><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br></pre></td></tr></table></figure>



<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
  </entry>
  <entry>
    <title>[踩坑玄学]隐身[&amp;nbsp]</title>
    <url>/2020/05/05/%E5%9D%91%E7%8E%84%E5%AD%A6-%E9%9A%90%E8%BA%AB-nbsp/</url>
    <content><![CDATA[<p>具体如下</p>
<video src="http://q9uen5wtx.bkt.clouddn.com/%E7%8E%84%E5%AD%A6%EF%BC%9F.mp4" controls="controls" style="max-width: 100%; display: block; margin-left: auto; margin-right: auto;">
your browser does not support the video tag
</video>

<a id="more"></a>

<p>空格把left div顶到下一行了。</p>
<p>我删掉left div前面的空格就好了  之后就算再空格也不会影响，可能是极少数情况下编译器存在隐身的&amp;nbsp?  left div  左边少了一根线可能就是有个隐身的&amp;nbsp[捂脸哭]</p>
]]></content>
      <categories>
        <category>VSCode</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
        <tag>空格占位</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序重力感应Uav实现</title>
    <url>/2020/05/12/%E7%A8%8B%E5%BA%8F%E9%87%8D%E5%8A%9B%E6%84%9F%E5%BA%94%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h3><video src="http://q9uen5wtx.bkt.clouddn.com/%E9%87%8D%E5%8A%9B%E6%84%9F%E5%BA%94Uav.mp4" controls="controls" style="max-width: 100%;max-height:500px; display: block; margin-left: auto; margin-right: auto;">
your browser does not support the video tag
</video>

<a id="more"></a>

<p>直接贴代码吧</p>
<h3 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;image class=&quot;img&quot; style=&quot;-webkit-transition: transform .5s ease-out;-webkit-transform:translate3d(&#123;&#123;transformX&#125;&#125;px,&#123;&#123;transformY&#125;&#125;px,0)&quot; src=&quot;/Images/start1/whiteUav.png&quot;&gt;&lt;/image&gt;</span><br></pre></td></tr></table></figure>

<h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> data: &#123;</span><br><span class="line"> transformX:0,</span><br><span class="line"> transformY:0,</span><br><span class="line">   &#125;,</span><br><span class="line">   </span><br><span class="line">let obj = this;</span><br><span class="line">   var transformX = obj.data.transformX;</span><br><span class="line">   var transformY = obj.data.transformY;  //Y轴平移</span><br><span class="line">   wx.onAccelerometerChange(function (res) &#123;</span><br><span class="line">     console.log(res.x)</span><br><span class="line">     // console.log(res.y)</span><br><span class="line">     // console.log(res.z)</span><br><span class="line">     if (res.x &gt; 0) &#123;</span><br><span class="line">       transformX += 10;</span><br><span class="line">     &#125;</span><br><span class="line">     else if (res.x &lt; 0) &#123;</span><br><span class="line">       transformX -= 10;</span><br><span class="line">     &#125;</span><br><span class="line">     if (res.y &gt; 0) &#123;                     //Y轴平移</span><br><span class="line">       transformY -= 10;</span><br><span class="line">     &#125;</span><br><span class="line">     else if (res.y &lt; 0) &#123;</span><br><span class="line">       transformY += 10;</span><br><span class="line">     &#125;</span><br><span class="line">     if (transformY &gt; 220) &#123;    //限定下边界</span><br><span class="line">       transformY -= 10;</span><br><span class="line">     &#125;else if (transformY &lt; -300) &#123;  //限定上边界</span><br><span class="line">       transformY += 10;</span><br><span class="line">     &#125;</span><br><span class="line">     if (transformX &gt; 200) &#123;            //限定右边界</span><br><span class="line">       transformX -= 10;</span><br><span class="line">     &#125; else if (transformX &lt; -100) &#123;   //限定左边界</span><br><span class="line">       transformX += 10;</span><br><span class="line">     &#125;</span><br><span class="line">     obj.setData(&#123;</span><br><span class="line">       transformX: transformX,</span><br><span class="line">       transformY:transformY</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Spring 的事务管理</title>
    <url>/2019/11/11/Spring-%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/Spring-%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>实际开发中，操作数据库时还会涉及事物管理问题，为此Spring提供了专门用于事务处理的API。</p>
<p>In the actural development,it involves things management when operating a database,for this purpose Spring provides apis specifically for transaction processing.</p>
<a id="more"></a>

<p>依赖包：spring-tx-4.3.6.RELEASE的JAR包<br>3个接口文件PlatformTransactionManger、TransactionDefinition、TransactionStatus</p>
<h6 id="1、PlatformTransactionManger：Spring-提供的平台事物管理器，主要用于管理事物。其中包含了三个事物操作的方法"><a href="#1、PlatformTransactionManger：Spring-提供的平台事物管理器，主要用于管理事物。其中包含了三个事物操作的方法" class="headerlink" title="1、PlatformTransactionManger：Spring 提供的平台事物管理器，主要用于管理事物。其中包含了三个事物操作的方法"></a>1、PlatformTransactionManger：Spring 提供的平台事物管理器，主要用于管理事物。其中包含了三个事物操作的方法</h6><p>1）TransactionStatus getTransaction (TransactionDefinition definition):</p>
<p><strong>use to get Transaction Status</strong></p>
<p>2) void commit(TransactionStatus status):** use to commit Transaction **</p>
<p>3）void rollback(TransactionStatus status):** use to roll back the Transaction(回滚事务) **</p>
<p>TransactionStatus 对象就表示一个事物</p>
<h6 id="2、TransactionDefinition-：事物定义（描述）的对象-，定义了事物的规则，并且提供获取事物相关信息的方法"><a href="#2、TransactionDefinition-：事物定义（描述）的对象-，定义了事物的规则，并且提供获取事物相关信息的方法" class="headerlink" title="2、TransactionDefinition()：事物定义（描述）的对象 ，定义了事物的规则，并且提供获取事物相关信息的方法"></a>2、TransactionDefinition()：事物定义（描述）的对象 ，定义了事物的规则，并且提供获取事物相关信息的方法</h6><p>getName方法  getsolationLevel获取隔离级别  getPropagationBehavior获取事物传播行为  getTImeout获取事物超时时间  </p>
<h6 id="3、TransactionStatus-事物的状态-描述了某一时间点上事物的状态信息。"><a href="#3、TransactionStatus-事物的状态-描述了某一时间点上事物的状态信息。" class="headerlink" title="3、TransactionStatus:事物的状态 描述了某一时间点上事物的状态信息。"></a>3、TransactionStatus:事物的状态 描述了某一时间点上事物的状态信息。</h6><p>flush方法：刷新事物</p>
<p>hasSavepoint():是否存在保存点</p>
<p>isCompleted():获取是否完成</p>
<p>isNewTransaction():获取是否是新事物</p>
<p>isRollbackOnly():获取是否回滚</p>
<p>setRollbackOnly():设置事物回滚</p>
<h3 id="事物管理方式"><a href="#事物管理方式" class="headerlink" title="事物管理方式"></a>事物管理方式</h3><p>1）传统的编程式事物管理</p>
<p>基于XML的声明式事物 <a href="tx:advice" target="_blank" rel="noopener">tx:advice</a>配置事物的通知（增强处理）<br>需要指定id 和 transaction-manager属性（指定事物管理器） 还需要配置 一个<a href="tx:attributes" target="_blank" rel="noopener">tx:attributes</a>，该子元素中可以配置多个<a href="tr:method" target="_blank" rel="noopener">tr:method</a>子元素来配置事物的细节。<br>** 配置<a href="tr:advice" target="_blank" rel="noopener">tr:advice</a>重点是配置<a href="tx:method" target="_blank" rel="noopener">tx:method</a>子元素 **</p>
<p>2）声明式事物管理</p>
<p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 转账</span><br><span class="line">	package com.itheima.jdbc;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface AccountDao &#123;</span><br><span class="line">	// 添加</span><br><span class="line">	public int addAccount(Account account);</span><br><span class="line">	// 更新</span><br><span class="line">	public int updateAccount(Account account);</span><br><span class="line">	// 删除</span><br><span class="line">	public int deleteAccount(int id);</span><br><span class="line">	</span><br><span class="line">	// 通过id查询</span><br><span class="line">	public Account findAccountById(int id);</span><br><span class="line">	// 查询所有账户</span><br><span class="line">	public List&lt;Account&gt; findAllAccount();</span><br><span class="line">	</span><br><span class="line">	// 转账</span><br><span class="line">	public void transfer(String outUser,String inUser,Double money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.itheima.jdbc;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">import org.springframework.jdbc.core.RowMapper;</span><br><span class="line">public class AccountDaoImpl implements AccountDao &#123;</span><br><span class="line">	// 声明JdbcTemplate属性及其setter方法</span><br><span class="line">	private JdbcTemplate jdbcTemplate;</span><br><span class="line">	public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;</span><br><span class="line">		this.jdbcTemplate = jdbcTemplate;</span><br><span class="line">	&#125;</span><br><span class="line">    // 添加账户</span><br><span class="line">	public int addAccount(Account account) &#123;</span><br><span class="line">		// 定义SQL</span><br><span class="line">		String sql = &quot;insert into account(id,username,balance) value(?,?,?)&quot;;</span><br><span class="line">		// 定义数组来存放SQL语句中的参数</span><br><span class="line">		Object[] obj = new Object[] &#123;</span><br><span class="line">				           account.getId(),</span><br><span class="line">                           account.getUsername(), </span><br><span class="line">                           account.getBalance() </span><br><span class="line">         &#125;;</span><br><span class="line">		// 执行添加操作，返回的是受SQL语句影响的记录条数</span><br><span class="line">		int num = this.jdbcTemplate.update(sql, obj);</span><br><span class="line">		return num;</span><br><span class="line">	&#125;</span><br><span class="line">	// 更新账户</span><br><span class="line">	public int updateAccount(Account account) &#123;</span><br><span class="line">		// 定义SQL</span><br><span class="line">		String sql = &quot;update account set username=?,balance=? where id = ?&quot;;</span><br><span class="line">		// 定义数组来存放SQL语句中的参数</span><br><span class="line">		Object[] params = new Object[] &#123; </span><br><span class="line">                               account.getUsername(), </span><br><span class="line">                               account.getBalance(), </span><br><span class="line">                               account.getId() </span><br><span class="line">          &#125;;</span><br><span class="line">		// 执行添加操作，返回的是受SQL语句影响的记录条数</span><br><span class="line">		int num = this.jdbcTemplate.update(sql, params);</span><br><span class="line">		return num;</span><br><span class="line">	&#125;</span><br><span class="line">	// 删除账户</span><br><span class="line">	public int deleteAccount(int id) &#123;</span><br><span class="line">		// 定义SQL</span><br><span class="line">		String sql = &quot;delete  from account where id = ? &quot;;</span><br><span class="line">		// 执行添加操作，返回的是受SQL语句影响的记录条数</span><br><span class="line">		int num = this.jdbcTemplate.update(sql, id);</span><br><span class="line">		return num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 通过id查询账户数据信息</span><br><span class="line">	public Account findAccountById(int id) &#123;</span><br><span class="line">	    //定义SQL语句</span><br><span class="line">	    String sql = &quot;select * from account where id = ?&quot;;</span><br><span class="line">	    // 创建一个新的BeanPropertyRowMapper对象</span><br><span class="line">	    RowMapper&lt;Account&gt; rowMapper = </span><br><span class="line">	new BeanPropertyRowMapper&lt;Account&gt;(Account.class);</span><br><span class="line">	    // 将id绑定到SQL语句中，并通过RowMapper返回一个Object类型的单行记录</span><br><span class="line">	    return this.jdbcTemplate.queryForObject(sql, rowMapper, id);</span><br><span class="line">	&#125;</span><br><span class="line">	// 查询所有账户信息</span><br><span class="line">	public List&lt;Account&gt; findAllAccount() &#123;</span><br><span class="line">	    // 定义SQL语句</span><br><span class="line">	    String sql = &quot;select * from account&quot;;</span><br><span class="line">	    // 创建一个新的BeanPropertyRowMapper对象</span><br><span class="line">	    RowMapper&lt;Account&gt; rowMapper = </span><br><span class="line">	new BeanPropertyRowMapper&lt;Account&gt;(Account.class);</span><br><span class="line">	    // 执行静态的SQL查询，并通过RowMapper返回结果</span><br><span class="line">	    return this.jdbcTemplate.query(sql, rowMapper);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改配置文件applicationContext.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; </span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans </span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span><br><span class="line">    http://www.springframework.org/schema/tx </span><br><span class="line">    http://www.springframework.org/schema/tx/spring-tx-4.3.xsd</span><br><span class="line">    http://www.springframework.org/schema/context </span><br><span class="line">    http://www.springframework.org/schema/context/spring-context-4.3.xsd</span><br><span class="line">    http://www.springframework.org/schema/aop </span><br><span class="line">    http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- 1.配置数据源 --&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; </span><br><span class="line">    class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">		&lt;!--数据库驱动 --&gt;</span><br><span class="line">		&lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;</span><br><span class="line">		&lt;!--连接数据库的url --&gt;</span><br><span class="line">		&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/spring&quot; /&gt;</span><br><span class="line">		&lt;!--连接数据库的用户名 --&gt;</span><br><span class="line">		&lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">		&lt;!--连接数据库的密码 --&gt;</span><br><span class="line">		&lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">   &lt;!-- 2.配置JDBC模板 --&gt;</span><br><span class="line">   &lt;bean id=&quot;jdbcTemplate&quot; </span><br><span class="line">          class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;</span><br><span class="line">		 &lt;!-- 默认必须使用数据源 --&gt;</span><br><span class="line">		 &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">   &lt;!--3.定义id为accountDao的Bean --&gt;</span><br><span class="line">   &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.jdbc.AccountDaoImpl&quot;&gt;</span><br><span class="line">		 &lt;!-- 将jdbcTemplate注入到AccountDao实例中 --&gt;</span><br><span class="line">		 &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot; /&gt;</span><br><span class="line">   &lt;/bean&gt;	</span><br><span class="line">   &lt;!-- 4.事务管理器，依赖于数据源 --&gt;</span><br><span class="line">   &lt;bean id=&quot;transactionManager&quot; class=</span><br><span class="line">   &quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">   &lt;/bean&gt;	</span><br><span class="line">   &lt;!-- 5.编写通知：对事务进行增强(通知),需要编写对切入点和具体执行事务细节 --&gt;</span><br><span class="line">   &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">		&lt;tx:attributes&gt;</span><br><span class="line">			&lt;!-- name：*表示任意方法名称 --&gt;</span><br><span class="line">			&lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; </span><br><span class="line">                           isolation=&quot;DEFAULT&quot; read-only=&quot;false&quot; /&gt;</span><br><span class="line">		&lt;/tx:attributes&gt;</span><br><span class="line">	&lt;/tx:advice&gt;</span><br><span class="line">	&lt;!-- 6.编写aop，让spring自动对目标生成代理，需要使用AspectJ的表达式 --&gt;</span><br><span class="line">	&lt;aop:config&gt;</span><br><span class="line">		&lt;!-- 切入点 --&gt;</span><br><span class="line">		&lt;aop:pointcut expression=&quot;execution(* com.itheima.jdbc.*.*(..))&quot;</span><br><span class="line">			id=&quot;txPointCut&quot; /&gt;</span><br><span class="line">		&lt;!-- 切面：将切入点与通知整合 --&gt;</span><br><span class="line">		&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot; /&gt;</span><br><span class="line">	&lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>


<h6 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.itheima.jdbc;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import </span><br><span class="line">org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">//测试类</span><br><span class="line">public class TransactionTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void xmlTest()&#123;</span><br><span class="line">		ApplicationContext applicationContext = </span><br><span class="line">		   new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">		// 获取AccountDao实例</span><br><span class="line">		AccountDao accountDao = </span><br><span class="line">            (AccountDao)applicationContext.getBean(&quot;accountDao&quot;);</span><br><span class="line">		// 调用实例中的转账方法</span><br><span class="line">		accountDao.transfer(&quot;Jack&quot;, &quot;Rose&quot;, 100.0);</span><br><span class="line">	    // 输出提示信息</span><br><span class="line">	    System.out.println(&quot;转账成功！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void annotationTest()&#123;</span><br><span class="line">	    ApplicationContext applicationContext = </span><br><span class="line">	new ClassPathXmlApplicationContext(&quot;applicationContext-annotation.xml&quot;);</span><br><span class="line">	    // 获取AccountDao实例</span><br><span class="line">	    AccountDao accountDao = </span><br><span class="line">	(AccountDao)applicationContext.getBean(&quot;accountDao&quot;);</span><br><span class="line">	    // 调用实例中的转账方法</span><br><span class="line">	    accountDao.transfer(&quot;Jack&quot;, &quot;Rose&quot;, 100.0);</span><br><span class="line">	    // 输出提示信息</span><br><span class="line">	    System.out.println(&quot;转账成功！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring事物管理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理测试习题整理【一】（含答案解析）</title>
    <url>/2019/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8B%E8%AF%95%E4%B9%A0%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E5%90%AB%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8B%E8%AF%95%E4%B9%A0%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E5%90%AB%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%89/</url>
    <content><![CDATA[<p>目前共整理了三章</p>
<a id="more"></a>


<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算机问世至今，新型机器不断推陈出新，不管怎样更新，依然保有“存储程序”的概念，最早提出这种概念的是______。</span><br><span class="line"></span><br><span class="line">A冯. 诺依曼</span><br><span class="line">B巴贝奇</span><br><span class="line">C贝尔</span><br><span class="line">D帕斯卡</span><br><span class="line"></span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.邮局把信件进行自动分拣，使用的计算机技术是______。</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line"> 机器证明</span><br><span class="line">B</span><br><span class="line">自然语言理解</span><br><span class="line">C</span><br><span class="line">计算机辅助设计</span><br><span class="line">D</span><br><span class="line">机器翻译</span><br><span class="line">E</span><br><span class="line">模式识别</span><br><span class="line">F</span><br><span class="line">自动控制</span><br><span class="line"></span><br><span class="line">E</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 计算机科技文献中，英文缩写CAI代表______。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A</span><br><span class="line">计算机辅助管理</span><br><span class="line">B</span><br><span class="line">计算机辅助设计</span><br><span class="line">C</span><br><span class="line">计算机辅助加工</span><br><span class="line">D</span><br><span class="line">计算机辅助制造</span><br><span class="line">E</span><br><span class="line">计算机辅助教学</span><br><span class="line">F</span><br><span class="line">计算机辅助学习</span><br><span class="line"></span><br><span class="line">E</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">微型计算机的发展以______技术为指标。</span><br><span class="line"></span><br><span class="line">微处理器</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算机中常以主频来评价机器的性能。以下为主频单位的是______。</span><br><span class="line"></span><br><span class="line">MHz</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算机运算速度的单位是______。</span><br><span class="line"></span><br><span class="line">MIPS</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1946年研制成功的第一台电子数字计算机称为______，1949年研制成功的第一台程序内存的计算机称为______。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENIAC， EDVAC</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算机与日常使用的袖珍计算器的本质区别在于______。</span><br><span class="line"></span><br><span class="line">自动化程度的高低</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下列______属于应用软件。</span><br><span class="line"></span><br><span class="line">文本处理</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作系统最现出现在_______。</span><br><span class="line">第3代计算机</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">至今为止，计算机中的所有信息仍以二进制方式表示的理由是______。</span><br><span class="line"></span><br><span class="line">###物理器件性能所至</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPU主要包括______。</span><br><span class="line">控制器、运算器</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">完整的计算机应包括______。</span><br><span class="line"></span><br><span class="line">配套的硬件设备和软件系统</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目前我们所说的个人台式商用机属于_______。</span><br><span class="line">###微型机</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENIAC属于晶体管计算机</span><br><span class="line">F</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编译方式是使用编译程序把源程序编译成机器代码的目标程序</span><br><span class="line">T</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算机唯一能够直接执行的语言是机器语言</span><br><span class="line">T</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用高级语言编写的程序称为目标程序</span><br><span class="line"></span><br><span class="line">F</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">冯诺依曼计算机体系结构的特点是什么？</span><br><span class="line">1、处理的数据和指令一律二进制</span><br><span class="line">2、顺序执行程序</span><br><span class="line">3、采用存储程序的方式</span><br><span class="line">4、计算机硬件由 运算器 、控制器、存储器、输入、输出设备五大部分组成</span><br><span class="line">5、用总线控制</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算机的主要性能指标有哪些？它们的具体含义是什么？</span><br><span class="line"> 运算速度、字长、内存储器的容量、外存储器的容量、主频</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算机的硬件由哪些部件组成？</span><br><span class="line"> 控制器、存储器、输入设备、输出设备、运算器</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简要说明计算机系统的层次结构</span><br><span class="line"> 1、硬联逻辑级</span><br><span class="line">2、微程序级</span><br><span class="line">3、传统机器级</span><br><span class="line">4、操作系统</span><br><span class="line">5、汇编语言级</span><br><span class="line">6、高级语言级</span><br><span class="line">7、应用语言级</span><br></pre></td></tr></table></figure>

<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><h2 id><a href="#" class="headerlink" title="?"></a>?</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通常把表示信息的数字符号称为什么？</span><br><span class="line"></span><br><span class="line">数码</span><br><span class="line"></span><br><span class="line">以下叙述错误的是______。</span><br><span class="line">A</span><br><span class="line">表示信息的数字符号称为代码</span><br><span class="line">B</span><br><span class="line">任何进制的数据都有基数和各位的”位权”</span><br><span class="line">C</span><br><span class="line">二进制数据的加减运算规则与逻辑加运算规则相同</span><br><span class="line">D</span><br><span class="line"> 8进制数据逢八进一 </span><br><span class="line"> </span><br><span class="line"> 正确答案：C ?????</span><br><span class="line"> (加法运算,其运算等价于两个数字的十进制数相加后转换成二进制,而逻辑运算是按位计算)</span><br></pre></td></tr></table></figure>

<h3 id="zy★"><a href="#zy★" class="headerlink" title="zy★"></a>zy★</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一种BCD码，其中0－9的编码为0000，0001，0010，0011，0100，0101，0110，0111，1110，1111，则各位的权值为______。</span><br><span class="line"></span><br><span class="line">2421</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在小型或微型计算机里，普遍采用的字符编码是______。</span><br><span class="line"></span><br><span class="line"> ASCⅡ码</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据国标规定，每个汉字在计算机内占用______存储。</span><br><span class="line">二个字节</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">十进制分数27/64的十六进制数表示为______。</span><br><span class="line">0.6CH</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假定下列字符码中有奇偶校验位，但没有数据错误，采用偶校校验的字符码是______。</span><br><span class="line">11001001</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假定下列字符码中有奇偶校验位，但没有数据错误，采用偶校校验的字符码是______。</span><br><span class="line"></span><br><span class="line">11001001</span><br></pre></td></tr></table></figure>
<h3 id="ct★"><a href="#ct★" class="headerlink" title="ct★"></a>ct★</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">若浮点数的机器表示中，尾数用补码表示，则判断该浮点数是否为规格化的方法是尾数的最高数值位______。 </span><br><span class="line"></span><br><span class="line">与尾符相反 </span><br><span class="line">【数符为0，这个数就是正数，正数补码就是其本身，其最高有效位(阶码使用标准移码的话规格化后尾数最高有效位就是小数点后第一位)必定为1，数符0和最高有效位的1相异。</span><br><span class="line"></span><br><span class="line">数符为1，这个数就是个负数，求负数的补码有一步叫按位取反(一般来说浮点数可以存储的有效位不会小于6位)，原本最高有效位的1变成了0，所以数符1和最高有效位的0相异。）】</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在机器数______中，零的表示形式是唯一的。</span><br><span class="line"></span><br><span class="line">补码和移码</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指令和数据都以十进制形式存放，（2000）10化成十六进制数是______。</span><br><span class="line"></span><br><span class="line">（7D0）16  </span><br><span class="line">【二进制转十六进制的时候要右移左边补0】</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下列数中最小的数是______。</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line">（100010）BCD </span><br><span class="line">B</span><br><span class="line">（100101）2     </span><br><span class="line">C</span><br><span class="line">（50）8      </span><br><span class="line">D</span><br><span class="line">（625）16</span><br><span class="line"></span><br><span class="line">A</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 在定点二进制运算器中，减法运算一般通过______来实现。</span><br><span class="line"></span><br><span class="line">补码运算的二进制加法器</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">下列数中最大的数为______。</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line">（143）5</span><br><span class="line">B</span><br><span class="line">（76）8 </span><br><span class="line">C</span><br><span class="line">（10010101）2    </span><br><span class="line">D</span><br><span class="line">（227）8  </span><br><span class="line"></span><br><span class="line">D</span><br><span class="line">[143 -&gt; 1*5^2+4*5^1+3*5^0=(48)10进制 -》110000二进制]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下列叙述正确的是______。</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line"> 定点数表示的是整数</span><br><span class="line">B</span><br><span class="line">对一个数据的原码的各位取反而且在末位再加1就可以得到这个数据的补码</span><br><span class="line">C</span><br><span class="line">原码是表示无符号数的编码方法</span><br><span class="line">D</span><br><span class="line">二进制数据表示在计算机中容易实现</span><br><span class="line"></span><br><span class="line">D</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在余3码表示的二-十进制数中，代码0011代表十进制数的______。</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">[余3码 :余3码是8421 BCD码的每个码组加3(0011)形成的。常用于BCD码的运算电路中。 ]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设X= —0.1011，则[X]补为______。</span><br><span class="line"></span><br><span class="line">1.0101</span><br></pre></td></tr></table></figure>

<h2 id="ct★-1"><a href="#ct★-1" class="headerlink" title="ct★"></a>ct★</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">______表示法主要用于表示浮点数中的阶码</span><br><span class="line"></span><br><span class="line">移码</span><br><span class="line">【移码（又叫增码）是符号位取反的补码，一般用指数的移码减去1来做浮点数的阶码，引入的目的是为了保证浮点数的机器零为全0。】</span><br><span class="line"></span><br><span class="line">【原码：1001101，反码，补码，移码各是多少？</span><br><span class="line"></span><br><span class="line">解：首位数字表示正负不做变（1为负数，0为正数）</span><br><span class="line"></span><br><span class="line">反码：1110010（正数反码等于原数，题中为负数，则除首位数对应取反）</span><br><span class="line"></span><br><span class="line">补码：1110011（得出反码数基础上末位加一）</span><br><span class="line"></span><br><span class="line">移码：0110011（补码符号位第一位数字取反）</span><br><span class="line">】</span><br></pre></td></tr></table></figure>
<h2 id="zy★-1"><a href="#zy★-1" class="headerlink" title="zy★"></a>zy★</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个8位的二进制整数，若采用补码表示，且由3个“1”和5个“0”组成，则最小值为______。</span><br><span class="line"></span><br><span class="line"> -125</span><br><span class="line"> 【首先反推补码应该是：10000011</span><br><span class="line">  源码则为11111101 即-125</span><br><span class="line"> 】</span><br></pre></td></tr></table></figure>
<p>##到23题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在小型机运算器中，通过移位器对一个通用寄存器中存放的一个正定点数进行乘2操作（假定乘2后不会溢出），其方法是将该寄存器中的数据送入ALU，经移位器______。</span><br><span class="line"></span><br><span class="line">A左移1位</span><br><span class="line">B右移1位</span><br><span class="line">C左移2位</span><br><span class="line">D右移2位</span><br><span class="line"></span><br><span class="line">A</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">若存储器的容量为128KX8位，求：(1)访问该芯片需要多少位地址？(2)假定该芯片在存储器中首地址为A0000H，则末地址应为多少？</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>用js做机器学习(一)【基础准备】</title>
    <url>/2019/11/12/%E7%94%A8js%E5%81%9A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%B8%80-%E3%80%90%E5%9F%BA%E7%A1%80%E5%87%86%E5%A4%87%E3%80%91/%E7%94%A8js%E5%81%9A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%B8%80-%E3%80%90%E5%9F%BA%E7%A1%80%E5%87%86%E5%A4%87%E3%80%91/</url>
    <content><![CDATA[<p>还是很想用JS实现数据预处理来跑机器学习算法<br>开始之前首先要对JS的一些基础知识有了解 比如Js的数据类型、正则表达式、类型转换等（此文将不断扩充）</p>
<a id="more"></a>

<h2 id="一、Js数据类型"><a href="#一、Js数据类型" class="headerlink" title="一、Js数据类型"></a>一、Js数据类型</h2><p>字符串值，数值，布尔值，数组，对象。</p>
<p>JavaScript 变量能够保存多种数据类型：数值、字符串值、数组、对象等等：</p>
<p>数据类型的概念<br>在编程过程中，数据类型是重要的概念。</p>
<p>为了能够操作变量，了解数据类型是很重要的。</p>
<p>如果没有数据类型，计算机就无法安全地解决这道题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = &quot;XiaoMi&quot;+6;</span><br></pre></td></tr></table></figure>
<p>x的结果为：XiaoMi6</p>
<p>JavaScript 从左向右计算表达式。不同的次序会产生不同的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = &quot;XiaoMi&quot;+6+&quot;plus&quot;;</span><br></pre></td></tr></table></figure>

<p>x的结果为：XiaoMi6plus</p>
<h5 id="JavaScript-拥有动态类型"><a href="#JavaScript-拥有动态类型" class="headerlink" title="JavaScript 拥有动态类型"></a>JavaScript 拥有动态类型</h5><p>JavaScript 拥有动态类型。这意味着相同变量可用作不同类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x;               // 现在 x 是 undefined</span><br><span class="line">var x = 6;           // 现在 x 是数值</span><br><span class="line">var x = &quot;Jamin&quot;;</span><br></pre></td></tr></table></figure>

<h5 id="可以在字符串内使用引号，只要这些引号与包围字符串的引号不匹配："><a href="#可以在字符串内使用引号，只要这些引号与包围字符串的引号不匹配：" class="headerlink" title="可以在字符串内使用引号，只要这些引号与包围字符串的引号不匹配："></a>可以在字符串内使用引号，只要这些引号与包围字符串的引号不匹配：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var answer = &quot;It&apos;s nice&quot;;             // 双引号内的单引号</span><br><span class="line">var answer = &quot;He is called &apos;Jamin&apos;&quot;;    // 双引号内的单引号</span><br><span class="line">var answer = &apos;He is called &quot;Jamin&quot;&apos;;    // 单引号内的双引号</span><br></pre></td></tr></table></figure>

<h5 id="JavaScript-数值"><a href="#JavaScript-数值" class="headerlink" title="JavaScript 数值"></a>JavaScript 数值</h5><p>JavaScript 只有一种数值类型。</p>
<p>写数值时用不用小数点均可</p>
<p>超大或超小的数值可以用科学计数法来写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x1 = 34.00;     // 带小数点</span><br><span class="line">var x2 = 34;        // 不带小数点</span><br><span class="line">var y = 123e5;      // 12300000</span><br><span class="line">var z = 123e-5;     // 0.00123</span><br></pre></td></tr></table></figure>

<h5 id="JavaScript-对象"><a href="#JavaScript-对象" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h5><p>JavaScript 对象用花括号来书写。</p>
<p>对象属性是 name:value 对，由逗号分隔。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;, age:62, eyeColor:&quot;blue&quot;&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h5><p>可使用 JavaScript 的 typeof 来确定 JavaScript 变量的类型：</p>
<p>typeof 运算符返回变量或表达式的类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof &quot;&quot;                  // 返回 &quot;string&quot;</span><br><span class="line">typeof &quot;Bill&quot;              // 返回 &quot;string&quot;</span><br><span class="line">typeof &quot;Bill Gates&quot;          // 返回 &quot;string&quot;</span><br></pre></td></tr></table></figure>

<p><strong>typeof 运算符对数组返回 “object”，因为在 JavaScript 中数组属于对象。</strong></p>
<p><strong><em>任何变量均可通过设置值为 undefined 进行清空。其类型也将是 undefined。</em></strong></p>
<p><strong>空值与 undefined 不是一回事。</strong></p>
<p><strong>空的字符串变量既有值也有类型。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var car = &quot;&quot;;                // 值是 &quot;&quot;，类型是 &quot;string&quot;</span><br></pre></td></tr></table></figure>

<h5 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h5><p>在 JavaScript 中，null 是 “nothing”。它被看做不存在的事物。</p>
<p>不幸的是，在 JavaScript 中，null 的数据类型是对象。</p>
<p>您可以把 null 在 JavaScript 中是对象理解为一个 bug。它本应是 null。</p>
<p>您可以通过设置值为 null 清空对象</p>
<p>您也可以通过设置值为 undefined 清空对象：</p>
<p><strong>Undefined 与 Null 的区别</strong></p>
<p>Undefined 与 null 的值相等，但类型不相等：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof undefined              // undefined</span><br><span class="line">typeof null                   // object</span><br><span class="line">null === undefined            // false</span><br><span class="line">null == undefined             // true</span><br></pre></td></tr></table></figure>

<h5 id="原始数据"><a href="#原始数据" class="headerlink" title="原始数据"></a>原始数据</h5><p>原始数据值是一种没有额外属性和方法的单一简单数据值。</p>
<p>typeof 运算符可返回以下原始类型之一：</p>
<p>string<br>number<br>boolean<br>undefined</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof &quot;Bill&quot;              // 返回 &quot;string&quot;</span><br><span class="line">typeof 3.14                // 返回 &quot;number&quot;</span><br><span class="line">typeof true                // 返回 &quot;boolean&quot;</span><br><span class="line">typeof false               // 返回 &quot;boolean&quot;</span><br><span class="line">typeof x                   // 返回 &quot;undefined&quot; (假如 x 没有值)</span><br></pre></td></tr></table></figure>
<h5 id="复杂数据"><a href="#复杂数据" class="headerlink" title="复杂数据"></a>复杂数据</h5><p>typeof 运算符可返回以下两种类型之一：</p>
<p>function<br>object</p>
<p><strong>typeof 运算符把对象、数组或 null 返回 object。</strong></p>
<p>typeof 运算符不会把函数返回 object。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof &#123;name:&apos;Bill&apos;, age:62&#125; // 返回 &quot;object&quot;</span><br><span class="line">typeof [1,2,3,4]             // 返回 &quot;object&quot; (并非 &quot;array&quot;，参见下面的注释)</span><br><span class="line">typeof null                  // 返回 &quot;object&quot;</span><br><span class="line">typeof function myFunc()&#123;&#125;   // 返回 &quot;function&quot;</span><br></pre></td></tr></table></figure>
<p><strong>typeof 运算符把数组返回为 “object”，因为在 JavaScript 中数组即对象。</strong></p>
<h2 id="二、JavaScript-正则表达式（未完-）"><a href="#二、JavaScript-正则表达式（未完-）" class="headerlink" title="二、JavaScript 正则表达式（未完~）"></a>二、JavaScript 正则表达式（未完~）</h2><p>正则表达式是构成搜索模式的字符序列。</p>
<p>该搜索模式可用于文本搜索和文本替换操作。</p>
]]></content>
  </entry>
  <entry>
    <title>机器学习期末复习简答题</title>
    <url>/2019/12/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AE%80%E7%AD%94%E9%A2%98/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h3><p>就是期末可能会考的简答题汇总，答案偏个人+网上找的~</p>
<a id="more"></a>

<h5 id="机器学习与人工智能的关系"><a href="#机器学习与人工智能的关系" class="headerlink" title="机器学习与人工智能的关系"></a>机器学习与人工智能的关系</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">机器学习是人工智能的子集也是人工智能的基础，</span><br><span class="line">人工智能除了机器学习还要知识表示、自动推理、知识获取等。</span><br></pre></td></tr></table></figure>

<h5 id="机器学习与数据挖掘的关系"><a href="#机器学习与数据挖掘的关系" class="headerlink" title="机器学习与数据挖掘的关系"></a>机器学习与数据挖掘的关系</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">数据挖掘可以认为是数据库技术与机器学习的交叉，它利用数据库技术来管理海量的数据，并利用机器学习和统计分析来进行数据分析。</span><br><span class="line"></span><br><span class="line">机器学习：广泛的定义为 “利用经验来改善计算机系统的自身性能。”，事实上，由于“经验”在计算机系统中主要是以数据的形式存在的,因此机器学习需要设法对数据进行分析,这就使得它逐渐成为智能数据分析技术的创新源之一,并且为此而受到越来越多的关注。</span><br><span class="line"></span><br><span class="line">数据挖掘：一种解释是“识别出巨量数据中有效的、新颖的、潜在有用的、最终可理解的模式的非平凡过程”，顾名思义，数据挖掘就是试图从海量数据中找出有用的知识。</span><br></pre></td></tr></table></figure>

<h5 id="举例说明机器学习的基本过程，并举例说明各步骤使用的方法"><a href="#举例说明机器学习的基本过程，并举例说明各步骤使用的方法" class="headerlink" title="举例说明机器学习的基本过程，并举例说明各步骤使用的方法"></a>举例说明机器学习的基本过程，并举例说明各步骤使用的方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、明确目标和要解决的问题</span><br><span class="line">（方法：对定性问题用分类算法，对定量分析可用回归方法，或者理解为预测问题用回归，分类问题用分类算法）</span><br><span class="line"></span><br><span class="line">2、收集数据</span><br><span class="line">（方法：选取有代表性的数据，分类问题避免出现样本数据不平衡，内存过大 考虑使用降维或改进算法）</span><br><span class="line"></span><br><span class="line">3、根据数据判断用supervised还是unsupervised机器学习模型</span><br><span class="line">（一般数据如果没有我们想要的标签，就考虑用聚类进行分类）</span><br><span class="line"></span><br><span class="line">4、数据预处理</span><br><span class="line">（方法：先进行探索，了解大致结构、数据噪声，分布等，可使用数据可视化方法或数据质量评价对数据质量进行评估，根据实际情况选择使用归一化，离散化、缺失值处理、去除共线性等）</span><br><span class="line"></span><br><span class="line">5、数据建模</span><br><span class="line">（方法：选取合适的特征，特征选择方法：相关系数、卡方检验、平均互信息、条件熵、后验概率和逻辑回归权重等方法。</span><br><span class="line">再把数据分为训练集和测试集）</span><br><span class="line"></span><br><span class="line">6、模型训练</span><br><span class="line">（方法：对模型超参进行调优）</span><br><span class="line"></span><br><span class="line">7、模型评估</span><br><span class="line">（方法：构建模型后，使用测试数据对模型进行测试和评估）</span><br><span class="line"></span><br><span class="line">8、模型应用</span><br><span class="line">（方法：用就完事了，再看看性能、稳定性啥的）</span><br></pre></td></tr></table></figure>


<h5 id="什么是标准差、方差和协方差？它们反映了数据的什么内容？"><a href="#什么是标准差、方差和协方差？它们反映了数据的什么内容？" class="headerlink" title="什么是标准差、方差和协方差？它们反映了数据的什么内容？"></a>什么是标准差、方差和协方差？它们反映了数据的什么内容？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方差（Variance）：用来度量随机变量和其数学期望（即均值）之间的偏离程度。</span><br><span class="line"></span><br><span class="line">标准差：方差开根号。</span><br><span class="line"></span><br><span class="line">协方差：E[(X-E[X])(Y-E[Y])]=E[XY]-E[X]E[Y]衡量两个变量之间的变化方向关系。</span><br><span class="line"></span><br><span class="line">标准差描述是样本集合的各个样本点到均值的距离分布，描述的是样本集的分散程度</span><br><span class="line"></span><br><span class="line">在机器学习中的方差就是估计值与其期望值的统计方差。如果进行多次重复验证的过程，就会发现模型在训练集上的表现并不固定，会出现波动，这些波动越大，它的方差就越大</span><br><span class="line"></span><br><span class="line">协方差主要用来度量两个随机变量关系，如果结果为正值，则说明两者是正相关的；结果为负值，说明两者是负相关的；如果为0，就是统计上的“相互独立”</span><br><span class="line"></span><br><span class="line">   标准差: 描述样本的分散程度。</span><br><span class="line">    方差：标准差的平方，模型预测稳定性。 </span><br><span class="line">   协方差:</span><br><span class="line">        结果为正值：两者正相关；</span><br><span class="line">        结果为负值：两者负相关；</span><br><span class="line">        如果为0：“相互独立”；</span><br></pre></td></tr></table></figure>

<h5 id="如何利用平均值和标准差判断数据的异常值？"><a href="#如何利用平均值和标准差判断数据的异常值？" class="headerlink" title="如何利用平均值和标准差判断数据的异常值？"></a>如何利用平均值和标准差判断数据的异常值？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据原值在均值±标准差*3范围外的都作为异常值剔除</span><br><span class="line"></span><br><span class="line">标准差可用于识别符合高斯或类高斯分布的数据中的异常值</span><br></pre></td></tr></table></figure>
<h5 id="何为正则化？其功能是什么？"><a href="#何为正则化？其功能是什么？" class="headerlink" title="何为正则化？其功能是什么？"></a>何为正则化？其功能是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在训练数据不够多时，或者overtraining时，常常会导致过拟合（overfitting）。正则化方法即为在此时向原始模型引入额外信息，以便防止过拟合和提高模型泛化性能的一类方法的统称。</span><br><span class="line"></span><br><span class="line">正则化是为了避免过拟合的手段。正则化为了结构风险最小化，在经验风险上加一个正则化项或惩罚项，正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大</span><br></pre></td></tr></table></figure>

<h5 id="PCA的基本思想"><a href="#PCA的基本思想" class="headerlink" title="PCA的基本思想"></a>PCA的基本思想</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过某种线性投影，将高维度的数据映射到低维的空间中，并期望再所投影的维度上数据的方差最大，以此使用较少的维度，同时保留较多原数据的维度。</span><br></pre></td></tr></table></figure>
<h5 id="如何理解L0、L1、L2正则化？"><a href="#如何理解L0、L1、L2正则化？" class="headerlink" title="如何理解L0、L1、L2正则化？"></a>如何理解L0、L1、L2正则化？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> L0：通过限制向量中非0的元素的个数实现模型优化；</span><br><span class="line"> L1：趋向于产生少量的特征，而其他的特征都是0；</span><br><span class="line"> L2：L2会选择更多的特征，这些特征都会接近于0。</span><br><span class="line"> </span><br><span class="line">（所有特征中只有少数特征起重要作用的情况下，选择L1更合适；</span><br><span class="line">所有特征中，大部分特征都能起作用，而且起的作用很平均，选择L2更合适；L1/L2范数让模型变得稀疏，增加模型的可解析性，可用于特征选择；L2范数让模型变得更简单，防止过拟合问题；</span><br><span class="line">）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L0正则化是通过限制向量中非0的元素的个数实现模型优化，用L0来正则化一个参数矩阵 W，目标是使其更稀疏，即W中的大部分元素都是0。很明显，如果通过最小化L0范数作为罚项，就是寻找最优的稀疏特征项。</span><br><span class="line">L1正则化是通过对向量中各个元素绝对值之和进行限制，任何的规则化算子，如果在wi = 0的地方不可微，并且可以分解为多项式的形式，那么这个规则化算子就可以实现稀疏。</span><br><span class="line">L2正则化是指向量各元素求平方和然后求平方根，用模最小化来确保w的每个元素都很小，都接近于0。</span><br></pre></td></tr></table></figure>


<h5 id="什么是交叉校验？常用方法有哪些？"><a href="#什么是交叉校验？常用方法有哪些？" class="headerlink" title="什么是交叉校验？常用方法有哪些？"></a>什么是交叉校验？常用方法有哪些？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">交叉验证是机器学习中确定超参数的通用的方法。</span><br><span class="line">k折交叉验证 、留一法</span><br></pre></td></tr></table></figure>


<h5 id="LDA的基本思想是什么？举例说明"><a href="#LDA的基本思想是什么？举例说明" class="headerlink" title="LDA的基本思想是什么？举例说明"></a>LDA的基本思想是什么？举例说明</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">通过将训练样本投影到低维度上，使得同类别的投影点尽可能接近，异类别样本的投影点尽可能远离，（即同类点方差尽可能小，而类之间的方差尽可能大）；对新样本，将其投影到低维空间，根据投影点的位置来确定其类别；</span><br><span class="line">应用LDA对鸢尾花（Iris）的样本数据进行分析。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDA 线性判别式分析：和PCA一样都是常用的降维技术，PCA从特征的协方差角度找比较好的投影，LDA更多是考虑了标注，即希望投影后不同类别之间的数据点的距离更大，同一类别的数据点更紧凑。</span><br><span class="line"></span><br><span class="line">线性判别分析的原理是对于给定的训练集，设法将样本投影到一条直线上，使得同类的投影点尽可能接近，异类样本的投影点尽可能远离；在对新样本进行分类时，将其投影到这条直线上，再根据投影点的位置来确定新样本的类别</span><br></pre></td></tr></table></figure>


<h5 id="为什么考虑特征提取？"><a href="#为什么考虑特征提取？" class="headerlink" title="为什么考虑特征提取？"></a>为什么考虑特征提取？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">特征提取目的是自动地构建新的特征，将原始数据转换为一组具有明显统计意义的核心特征</span><br><span class="line"></span><br><span class="line">特征提取是利用原有的特征根据一定的算法提取出原始特征中包含的抽象特征</span><br><span class="line">通过降维，可以减少数据量大大减少计算量，再就是避免被不重要的噪声干扰</span><br></pre></td></tr></table></figure>

<h5 id="线性回归的过程是什么？举例说明"><a href="#线性回归的过程是什么？举例说明" class="headerlink" title="线性回归的过程是什么？举例说明~"></a>线性回归的过程是什么？举例说明~</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a)         确定输入变量与目标变量间的回归模型，即变量间相关关系的数学表达式</span><br><span class="line"></span><br><span class="line">b)        根据样本估计并检验回归模型及未知参数</span><br><span class="line"></span><br><span class="line">c)         从众多的输入变量中，判断哪些变量对目标变量的影响是显著的</span><br><span class="line"></span><br><span class="line">d)        根据输入变量的已知值来估计目标变量的平均值并给出预测精度</span><br><span class="line"></span><br><span class="line">线性回归是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，运用十分广泛。</span><br><span class="line">比如预测房价，我们通过数据分析多个变量如地点附近医院个数、学校个数等分析与房价的关系，拟合出一个函数。来预测一个新的未知房价</span><br></pre></td></tr></table></figure>


<h5 id="逻辑回归为什么可以预测新样本的类别？举例说明其应用。"><a href="#逻辑回归为什么可以预测新样本的类别？举例说明其应用。" class="headerlink" title="逻辑回归为什么可以预测新样本的类别？举例说明其应用。"></a>逻辑回归为什么可以预测新样本的类别？举例说明其应用。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">逻辑回归是一种预测分析， 解释因变量与一个或多个自变量之间的关系，与线性回归不同之处就是它的目标变量有几种类别，所以逻辑回归主要用于解决分类问题，与线性回归相比，它是用概率的方式，预测出来属于某一分类的概率值。如果超过50%，则属于某一分类</span><br></pre></td></tr></table></figure>


<h5 id="分类解决什么问题？"><a href="#分类解决什么问题？" class="headerlink" title="分类解决什么问题？"></a>分类解决什么问题？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">将数据集中的样本划分到个各类中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">找一个函数判断输入数据所属的类别，可以是二类别问题（是/不是），也可以是多类别问题（在多个类别中判断输入数据具体属于哪一个类别）。与回归问题（regression）相比，分类问题的输出不再是连续值，而是离散值，用来指定其属于哪个类别。</span><br><span class="line">比如垃圾邮件识别，手写数字识别，人脸识别，语音识别等。。</span><br></pre></td></tr></table></figure>

<h5 id="常见的分类算法有哪些？举例说明"><a href="#常见的分类算法有哪些？举例说明" class="headerlink" title="常见的分类算法有哪些？举例说明"></a>常见的分类算法有哪些？举例说明</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">决策树 贝叶斯 人工神经网络 k-近邻 支持向量机 基于关联规则的分类 集成学习</span><br></pre></td></tr></table></figure>


<h5 id="简述决策树的生成过程"><a href="#简述决策树的生成过程" class="headerlink" title="简述决策树的生成过程"></a>简述决策树的生成过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">决策树的构建过程是按照属性的优先级或重要性来逐渐确定树的层次结构，使其叶子结点尽可能属于同一类别，一般采用局部最优的贪心策略来构建决策树。</span><br><span class="line"></span><br><span class="line">决策树是一种树形的结构，一般由根节点、父节点、子节点、叶子节点构成</span><br><span class="line"></span><br><span class="line">每一个分支代表着一个判断，每个叶子节点代表一种结果。</span><br><span class="line"></span><br><span class="line">最优的模型应该是：叶子节点中只包含一个类别的数据。</span><br><span class="line"></span><br><span class="line">从决策树根结点出发，自顶向下移动，在每个决策结点都会进行次划分，通过划分的结果将样本进行分类，导致不同的分支，最后到达个叶子结点，这个过程就是利用决策树进行分类的过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">步骤一：将所有的特征看成一个一个的节点，eg（拥有房产、婚姻状态、年收入这些特征，我们可以看成一个一个的节点。）</span><br><span class="line"></span><br><span class="line">步骤二：遍历当前特征的每一种分割方式，找到最好的分割点eg（婚姻状态这个特征，我们可以按照单身、已婚、离婚进行划分；也可以按照结过婚、没有结过婚进行划分）；将数据划分为不同的子节点，eg： N1、 N2….Nm；计算划分之后所有子节点的“纯度”信息</span><br><span class="line"></span><br><span class="line">步骤三：使用第二步遍历所有特征，选择出最优的特征，以及该特征的最优的划分方式，得出最终的子节点N1、 N2….Nm</span><br><span class="line"></span><br><span class="line">步骤四：对子节点N1、N2….Nm分别继续执行2-3步，直到每个最终的子节点都足够“纯”。</span><br></pre></td></tr></table></figure>


<h5 id="如何减少过拟合？"><a href="#如何减少过拟合？" class="headerlink" title="如何减少过拟合？"></a>如何减少过拟合？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">增加数据量，降低模型复杂度。通过正则化</span><br></pre></td></tr></table></figure>
<h5 id="1-混淆矩阵"><a href="#1-混淆矩阵" class="headerlink" title="1. 混淆矩阵"></a>1. 混淆矩阵</h5><p>在介绍各个率之前，先来介绍一下混淆矩阵。如果我们用的是个二分类的模型，那么把预测情况与实际情况的所有结果两两混合，结果就会出现以下4种情况，就组成了混淆矩阵。</p>
<p>P（Positive）：代表1</p>
<p>N（Negative）：代表0</p>
<p>T（True）：代表预测正确</p>
<p>F（False）：代表错误</p>
<p>TP：预测为1，预测正确，即实际1</p>
<p>FP：预测为1，预测错误，即实际0</p>
<p>FN：预测为0，预测错确，即实际1</p>
<p>TN：预测为0，预测正确即，实际0</p>
<h5 id="2-准确率"><a href="#2-准确率" class="headerlink" title="2. 准确率"></a>2. 准确率</h5><p>既然是个分类指标，我们可以很自然的想到准确率，准确率的定义是预测正确的结果占总样本的百分比，其公式如下：</p>
<p>准确率=(TP+TN)/(TP+TN+FP+FN)</p>
<h6 id="3-精准率"><a href="#3-精准率" class="headerlink" title="3. 精准率"></a>3. 精准率</h6><p>精准率（Precision）又叫查准率，它是针对****预测结果而言的，它的含义是在所有被预测为正的样本中实际为正的样本的概率，意思就是在预测为正样本的结果中，我们有多少把握可以预测正确，其公式如下：</p>
<p>精准率=TP/(TP+FP)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">精准率和准确率看上去有些类似，但是完全不同的两个概念。精准率代表对正样本结果中的预测准确程度，而准确率则代表整体的预测准确程度，既包括正样本，也包括负样本。</span><br></pre></td></tr></table></figure>
<h5 id="4-召回率"><a href="#4-召回率" class="headerlink" title="4. 召回率"></a>4. 召回率</h5><p>召回率（Recall）又叫查全率，它是针对原样本而言的，它的含义是在实际为正的样本中被预测为正样本的概率，其公式如下：</p>
<p>精准率=TP/(TP+FN)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">召回率越高，代表实际坏用户被预测出来的概率越高，它的含义类似：宁可错杀一千，绝不放过一个。</span><br></pre></td></tr></table></figure>



<h5 id="AUC与ROC的关系是什么？"><a href="#AUC与ROC的关系是什么？" class="headerlink" title="AUC与ROC的关系是什么？"></a>AUC与ROC的关系是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ROC图下的面积为AUC，AUC值越大，表示分类模型的预测准确性越高。（ROC越光滑，一般表示过拟合现象越轻）</span><br><span class="line"></span><br><span class="line">AUC(Area Under ROC Curve)，从名字可以看出AUC是ROC曲线下方的面积。当两个分类器的ROC曲线交叉时，就可以通过AUC来判断分类器的好坏了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这两个指标的选择也正是ROC和AUC可以无视样本不平衡的原因。这两个指标分别是：灵敏度和（1-特异度），也叫做真正率（TPR）和假正率（FPR）</span><br><span class="line"></span><br><span class="line">灵敏度（Sensitivity） = TP/(TP+FN)</span><br><span class="line"></span><br><span class="line">特异度（Specificity） = TN/(FP+TN)</span><br><span class="line"></span><br><span class="line">ROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。</span><br><span class="line"></span><br><span class="line">ROC（Receiver Operating Characteristic）曲线，又称接受者操作特征曲线。该曲线最早应用于雷达信号检测领域，用于区分信号与噪声。后来人们将其用于评价模型的预测能力，ROC曲线是基于混淆矩阵得出的。</span><br><span class="line"></span><br><span class="line">ROC曲线也是通过遍历所有阈值来绘制整条曲线的。如果我们不断的遍历所有阈值，预测的正样本和负样本是在不断变化的，相应的在ROC曲线图中也会沿着曲线滑动。</span><br><span class="line"></span><br><span class="line">TPR越高，同时FPR越低（即ROC曲线越陡），那么模型的性能就越好。</span><br></pre></td></tr></table></figure>

<h5 id="聚类分析的目的是什么？"><a href="#聚类分析的目的是什么？" class="headerlink" title="聚类分析的目的是什么？"></a>聚类分析的目的是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当我们的数据没有我们想要的特征的时候，通过聚类（按相似程度如距离远近等）划分类别 再打上标签，就能得到对我们有用的数据。</span><br></pre></td></tr></table></figure>

<h5 id="聚类与分类的关系？"><a href="#聚类与分类的关系？" class="headerlink" title="聚类与分类的关系？"></a>聚类与分类的关系？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">聚类是非监督式学习，分类是有监督学习。</span><br><span class="line">如果想利用分类方法来对数据进行分类，训练模型用的样本必须是有标签的，这样模型才能不断地学习、优化最后达到良好的分类效果</span><br></pre></td></tr></table></figure>



<h5 id="常见有哪些聚类方法？这些方法分别试用于哪些场合？"><a href="#常见有哪些聚类方法？这些方法分别试用于哪些场合？" class="headerlink" title="常见有哪些聚类方法？这些方法分别试用于哪些场合？"></a>常见有哪些聚类方法？这些方法分别试用于哪些场合？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">划分方法【k-means 】：适用于对大规模的数据集进行分类，以及处理复杂形状的聚类。</span><br><span class="line"></span><br><span class="line">层次方法【Birch、cure】：可以根据需求指定层数，知道要分几类的情况</span><br><span class="line"></span><br><span class="line">基于密度的方法：球状数据集能正确划分，但是非球状无法正确聚类，容易受到噪声影响。</span><br><span class="line"></span><br><span class="line">基于网格的方法：处理大数据集时效率高</span><br><span class="line"></span><br><span class="line">基于模型的方法：数据集满足一定的分布模型</span><br></pre></td></tr></table></figure>

<h5 id="聚类分析中，样本之间的距离常用的计算方法有哪些？"><a href="#聚类分析中，样本之间的距离常用的计算方法有哪些？" class="headerlink" title="聚类分析中，样本之间的距离常用的计算方法有哪些？"></a>聚类分析中，样本之间的距离常用的计算方法有哪些？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最短距离法、最长距离法、中间距离法、可变距离法、重心法、类平均法等。</span><br></pre></td></tr></table></figure>

<h5 id="k个假设聚类中心位置对k-均值算法的影响？"><a href="#k个假设聚类中心位置对k-均值算法的影响？" class="headerlink" title="k个假设聚类中心位置对k-均值算法的影响？"></a>k个假设聚类中心位置对k-均值算法的影响？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">影响比较大，不同的初始中心可能会导致不同的聚类结果。</span><br></pre></td></tr></table></figure>

<h5 id="简要说明基于划分的聚类方法的基本原理。"><a href="#简要说明基于划分的聚类方法的基本原理。" class="headerlink" title="简要说明基于划分的聚类方法的基本原理。"></a>简要说明基于划分的聚类方法的基本原理。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把包含n个样本的数据集，基于划分的方法将n个样本按照特定的度量划分为K个蔟，方法大多数是基于距离来划分。在每次划分过程中寻找最优解，然后基于最优解进行迭代计算。</span><br></pre></td></tr></table></figure>

<h5 id="支持向量机的基本原理是什么？"><a href="#支持向量机的基本原理是什么？" class="headerlink" title="支持向量机的基本原理是什么？"></a>支持向量机的基本原理是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个比较基于数学的算法，</span><br><span class="line">通过将样本的向量映射到高维空间中，寻找最优区分两类数据的超平面，使各分类的超平面的距离最大化，距离越大SVM的分类误差越小。</span><br></pre></td></tr></table></figure>

<h5 id="支持向量机适合解决什么问题？"><a href="#支持向量机适合解决什么问题？" class="headerlink" title="支持向量机适合解决什么问题？"></a>支持向量机适合解决什么问题？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">支持向量机用于二元分类问题，对于多元分类可以将其分解为多个二元分类问题，再进行分类。</span><br><span class="line"></span><br><span class="line">支持向量机在小样本、非线性及高维模式识别中表现出许多特有的优势，并能够推广应用到函数拟合等其他机器学习问题中。</span><br></pre></td></tr></table></figure>


<h5 id="支持向量机常用的核函数有？"><a href="#支持向量机常用的核函数有？" class="headerlink" title="支持向量机常用的核函数有？"></a>支持向量机常用的核函数有？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线性核函数、多项式核函数、径向基核函数、sigmoid Kernel</span><br></pre></td></tr></table></figure>

<h5 id="核函数的选择对支持向量机的性能有什么影响？"><a href="#核函数的选择对支持向量机的性能有什么影响？" class="headerlink" title="核函数的选择对支持向量机的性能有什么影响？"></a>核函数的选择对支持向量机的性能有什么影响？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">只要一个对称函数所对应的核矩阵半正定，它就能作为核函数使用。事实上，对于一个半正定核矩阵，总能找到一个与之对应的映射。核函数的使用，不一定能够准确的划分，只能说使用哪个核函数，能够逼近真实的划分效果。因此特征空间的好坏对支持向量机的性能至关重要。在不知道特征映射的形式时，我们并不知道什么样的核函数是合适的，而核函数也仅是隐式定义了这个特征空间。于是，核函数的选择成为了支持向量机的最大变数。若核函数选择不合适，则意味着映射到一个不合适的特征空间，很可能导致性能不佳。</span><br><span class="line">（对预测精度有重要影响。）</span><br><span class="line"></span><br><span class="line">特征数量多的时候适合线性核函数，因为运算速度快</span><br><span class="line"></span><br><span class="line">当多项式阶数高时复杂度会很高，正交归一化后的数据，优先使用多项式核函数。</span><br><span class="line"></span><br><span class="line">大多数情况下径向基核函数（高斯核函数）都有比较好的性能，不确定用哪种就用它。</span><br></pre></td></tr></table></figure>

<h5 id="数据降维有哪些常用的方法？"><a href="#数据降维有哪些常用的方法？" class="headerlink" title="数据降维有哪些常用的方法？"></a>数据降维有哪些常用的方法？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">答：主成分分析 (PCA)，奇异值分解，线性判别分析，局部线性嵌入，拉普拉斯特征映射，</span><br></pre></td></tr></table></figure>

<h5 id="PCA的基本思想-1"><a href="#PCA的基本思想-1" class="headerlink" title="PCA的基本思想"></a>PCA的基本思想</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">答：通过某种线性投影,将高伟的数据映射到低纬的空间中，并期望在所投影的维度上数据的方差最大，以此使用较少的维度，同时保留较多原数据的维度。</span><br></pre></td></tr></table></figure>
<h5 id="常用特征的选择方式。列举其方法。"><a href="#常用特征的选择方式。列举其方法。" class="headerlink" title="常用特征的选择方式。列举其方法。"></a>常用特征的选择方式。列举其方法。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">答：特征选择的目的主要是降维，从特征集合中挑选一组最具统计意义的特征子集来代表整体样本的特点。常见的有pearson相关系数，基尼指标，信息增益等。最简单的办法是琼剧所有特征子集，找到错误率最低的子集。特征选择可分为过滤方法，封装器方法和嵌入方法。</span><br></pre></td></tr></table></figure>
<h5 id="什么是过拟合问题，如何判断过拟合？"><a href="#什么是过拟合问题，如何判断过拟合？" class="headerlink" title="什么是过拟合问题，如何判断过拟合？"></a>什么是过拟合问题，如何判断过拟合？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">答：下面的话有点太官方了  什么是过拟合？大白话就是 泛化能力低 再白话一点就是测试误差高。 如何判断？看看测试误差是不是很高就行了</span><br><span class="line"></span><br><span class="line">通常对于分类算法可能产生两种类型的误差，分别是训练误差与泛化误差。训练误差代表此分类方法，对于现有训练样本级的拟合程度，泛化误差代表此方法的泛化能力，即对于新的样本数据的分类能力如何。模型的训练误差低，但是泛化误差比较高，则称分类模型过拟合。即过度拟合训练数据，导致模型的泛化能力，反而随着模型与训练数据的拟合程度增高而下降。随着分类模型对于样本的拟合程度逐渐增加，当决策数深度达到一定值，即使训练误差仍在下降，泛化误差却不断升高，产生过拟合现象。（书上的</span><br><span class="line">全摘录了自己总结吧）</span><br></pre></td></tr></table></figure>

<h5 id="k均值算法的原理是什么？步骤？"><a href="#k均值算法的原理是什么？步骤？" class="headerlink" title="k均值算法的原理是什么？步骤？"></a>k均值算法的原理是什么？步骤？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">答：K均值距离是基于划分的距离算法。计算样本点与类簇质心的距离，与类簇质心相近的样本点划分为同一类簇。K均值中，样本间的相似度由他们之间的距离决定。距离越近说明相似度越高，反之越低。</span><br></pre></td></tr></table></figure>

<h5 id="讨论初始的k个假设聚类中心位置对k均值算法的影响。"><a href="#讨论初始的k个假设聚类中心位置对k均值算法的影响。" class="headerlink" title="讨论初始的k个假设聚类中心位置对k均值算法的影响。"></a>讨论初始的k个假设聚类中心位置对k均值算法的影响。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">答：K均值算法中初始聚类中心的选取对算法结果影响很大。不同的初始中心可能会导致不同的聚类结果。选择一个新样本点加入聚类中心点集合中，其距离dx越大，被选中的可能性越高。</span><br></pre></td></tr></table></figure>
<h5 id="如何评价聚类方法的好坏？"><a href="#如何评价聚类方法的好坏？" class="headerlink" title="如何评价聚类方法的好坏？"></a>如何评价聚类方法的好坏？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">答：在数据质量高的情况下，一个好的聚类结果表明了数据中相对稳定的某种“模式 or 分布”，这个模式不会因为个别数据点的增删改而改变，且能够将数据尽可能分开。</span><br></pre></td></tr></table></figure>
<h5 id="DBSCAN算法的原理-步骤。"><a href="#DBSCAN算法的原理-步骤。" class="headerlink" title="DBSCAN算法的原理?步骤。"></a>DBSCAN算法的原理?步骤。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">答：DBSCAN是一种基于密度的聚类算法，这类密度聚类算法一般假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。通过将紧密相连的样本划为一类，这样就得到了一个聚类类别。通过将所有各组紧密相连的样本划为各个不同的类别，则我们就得到了最终的所有聚类类别结果。（原理 完整）</span><br><span class="line">原理：该算法利用基于密度的聚类的思想，即要求聚类空间中的一定区域内所包含对象的数目不小于某一给定的阈值。</span><br><span class="line">（原理 总结）</span><br><span class="line">DBSCAN 算法的步骤如下：</span><br><span class="line">1）从任一数据点 p 开始，对 p 点根据和 MinPts 进行判定。如果 p 是核心数据点，则建立新簇 S，并将 p 临域内的所有点归入 S；否则将 p 点标记为边界点或噪声点。</span><br><span class="line">2）对于 S 中除 p 点以外的点继续实施过程 1），继续扩充 S，直到所有的点都被判定处理。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习基础算法</tag>
        <tag>机器学习习题</tag>
      </tags>
  </entry>
  <entry>
    <title>成功解决java.lang.ClassNotFoundException: com.mysql.cj.jdbc.Driver</title>
    <url>/2019/11/13/%E6%88%90%E5%8A%9F%E8%A7%A3%E5%86%B3java-lang-ClassNotFoundException-com-mysql-cj-jdbc-Driver/%E6%88%90%E5%8A%9F%E8%A7%A3%E5%86%B3java-lang-ClassNotFoundException-com-mysql-cj-jdbc-Driver/</url>
    <content><![CDATA[<p>用Spring 通过applicationContext连接mySql</p>
<p>发现报错  于是改回传统方式尝试连接 代码如下</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@org.junit.Test</span><br><span class="line">	public void mainTest() &#123;</span><br><span class="line">//		// 加载配置文件</span><br><span class="line">//		ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">//		// 获取JdbcTemplate实例</span><br><span class="line">//		JdbcTemplate jdTemplate = (JdbcTemplate) applicationContext.getBean(&quot;jdbcTemplate&quot;);</span><br><span class="line">//		// 使用execute()方法执行SQL语句，创建用户账户管理表account</span><br><span class="line">//		jdTemplate.execute(&quot;create table account(&quot; + &quot;id int primary key auto_increment,&quot; + &quot;username varchar(50),&quot;</span><br><span class="line">//				+ &quot;balance double)&quot;);</span><br><span class="line">//		System.out.println(&quot;账户表account创建成功！&quot;);</span><br><span class="line"></span><br><span class="line">		Connection conn=null;</span><br><span class="line">		try</span><br><span class="line">		&#123;</span><br><span class="line">			Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);// 加载驱动程序，此次无需更改</span><br><span class="line">			System.out.println(&quot;registered success!&quot;);//输出registered success表示驱动加载成功</span><br><span class="line">			//创建对象连接，连接数据库，此例中employeedbms为数据库名，root为用户名，123456位密码，该三项均需根据实际情况进行修改，其它代码无需变动。注：确保数据库名、用户名和密码的准确性。</span><br><span class="line">//			conn = (Connection) DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/spring?useSSL=false&amp;serverTimezone=UTC&quot;,&quot;root&quot;,&quot;123456&quot;);</span><br><span class="line">			conn = (Connection) DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/spring?useSSL=true&amp;serverTimezone=GMT&quot;, &quot;root&quot;, &quot;123456&quot;);</span><br><span class="line">			System.out.println(&quot;connection success!&quot;);//输出connection success表示数据库已成功连接</span><br><span class="line">			conn.close();</span><br><span class="line">		&#125;</span><br><span class="line">		catch(Exception e)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(e);</span><br><span class="line">		&#125;</span><br><span class="line">		finally&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    ``` </span><br><span class="line"> 出现错误提示</span><br></pre></td></tr></table></figure>
<p> java.lang.ClassNotFoundException: com.mysql.cj.jdbc.Driver<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由于我用的是mySQL 8.0.18</span><br></pre></td></tr></table></figure><br> //下面这个命令可以查你的mysql版本<br> mysql -uroot -p<br> //打开MySQL也可以看到<br> //利用navicat连接mysql的客户端工具可以查看<br> //连接之后右键——详细信息<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据库连接要和5.x的版本不一样驱动也是不一样</span><br><span class="line"></span><br><span class="line">https://mvnrepository.com/</span><br><span class="line"></span><br><span class="line">到上面这个网站搜索 mysql-connector-java-8.0.18.jar</span><br><span class="line">下载后导入到项目中  不要只是拖进去 还需要去建立依赖 否则没法用</span><br><span class="line"></span><br><span class="line">比如idea，要在Project Structure 里面的Modules 对应下的项目中点+号导入驱动。</span><br><span class="line">再次运行传统的连接数据库代码 发现成功</span><br></pre></td></tr></table></figure><br>registered success!<br>connection success!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">注释掉用用以下xml配置连接数据库，也是成功</span><br></pre></td></tr></table></figure>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans 
     http://www.springframework.org/schema/beans/spring-beans-4.3.xsd"><br>    <!-- 1配置数据源 --><br>    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"><br>        <!--数据库驱动 --><br>        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"></property></bean></beans></p>
<!--        //com.mysql.jdbc.Driver-->
<pre><code>    &lt;!--连接数据库的url --&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring?serverTimezone=GMT&quot; /&gt;
    &lt;!--连接数据库的用户名 --&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
    &lt;!--连接数据库的密码 --&gt;
    &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;
&lt;/bean&gt;

&lt;/bean&gt;</code></pre>
```

<p>end</p>
]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
